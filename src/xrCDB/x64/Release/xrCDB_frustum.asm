; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z ; svector<_vector3<float>,48>::resize
PUBLIC	?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<1,1>::_box
PUBLIC	?_prim@?$frustum_collider@$00$00@@QEAAXK@Z	; frustum_collider<1,1>::_prim
PUBLIC	?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<1,0>::_box
PUBLIC	?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z	; frustum_collider<1,0>::_prim
PUBLIC	?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<0,1>::_box
PUBLIC	?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z	; frustum_collider<0,1>::_prim
PUBLIC	?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ; frustum_collider<0,0>::_box
PUBLIC	?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z	; frustum_collider<0,0>::_prim
PUBLIC	?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<1,1>::_init
PUBLIC	?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,1>::_stab
PUBLIC	?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<1,0>::_init
PUBLIC	?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,0>::_stab
PUBLIC	?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<0,1>::_init
PUBLIC	?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,1>::_stab
PUBLIC	?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ; frustum_collider<0,0>::_init
PUBLIC	?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,0>::_stab
PUBLIC	?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z ; CDB::COLLIDER::frustum_query
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z DD imagerel $LN26
	DD	imagerel $LN26+307
	DD	imagerel $unwind$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z DD imagerel $LN26
	DD	imagerel $LN26+307
	DD	imagerel $unwind$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z DD imagerel $LN26
	DD	imagerel $LN26+146
	DD	imagerel $unwind$?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z DD imagerel $LN26
	DD	imagerel $LN26+146
	DD	imagerel $unwind$?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN40
	DD	imagerel $LN40+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN40+134
	DD	imagerel $LN40+367
	DD	imagerel $chain$0$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN40+367
	DD	imagerel $LN40+383
	DD	imagerel $chain$1$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN32
	DD	imagerel $LN32+353
	DD	imagerel $unwind$?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN40
	DD	imagerel $LN40+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN40+134
	DD	imagerel $LN40+367
	DD	imagerel $chain$0$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN40+367
	DD	imagerel $LN40+383
	DD	imagerel $chain$1$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD imagerel $LN32
	DD	imagerel $LN32+353
	DD	imagerel $unwind$?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD imagerel $LN53
	DD	imagerel $LN53+21
	DD	imagerel $unwind$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD imagerel $LN53+21
	DD	imagerel $LN53+98
	DD	imagerel $chain$1$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD imagerel $LN53+98
	DD	imagerel $LN53+133
	DD	imagerel $chain$2$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD imagerel $LN53+133
	DD	imagerel $LN53+189
	DD	imagerel $chain$3$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD imagerel $LN53+189
	DD	imagerel $LN53+287
	DD	imagerel $chain$4$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD 021H
	DD	imagerel $LN53
	DD	imagerel $LN53+21
	DD	imagerel $unwind$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD 021H
	DD	imagerel $LN53+21
	DD	imagerel $LN53+98
	DD	imagerel $chain$1$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD 020521H
	DD	0c3405H
	DD	imagerel $LN53+21
	DD	imagerel $LN53+98
	DD	imagerel $chain$1$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD 040d21H
	DD	0ec40dH
	DD	0d7405H
	DD	imagerel $LN53
	DD	imagerel $LN53+21
	DD	imagerel $unwind$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z DD 060e01H
	DD	0f540eH
	DD	0f00a720eH
	DD	06006e008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 062501H
	DD	046825H
	DD	0c3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 021H
	DD	imagerel $LN40
	DD	imagerel $LN40+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 020521H
	DD	0c6405H
	DD	imagerel $LN40
	DD	imagerel $LN40+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 062501H
	DD	046825H
	DD	0d3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 062501H
	DD	046825H
	DD	0c3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 021H
	DD	imagerel $LN40
	DD	imagerel $LN40+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 020521H
	DD	0c6405H
	DD	imagerel $LN40
	DD	imagerel $LN40+134
	DD	imagerel $unwind$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z DD 062501H
	DD	046825H
	DD	0d3410H
	DD	0700c9210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 033001H
	DD	046830H
	DD	0a207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 033001H
	DD	046830H
	DD	0a207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z DD 071301H
	DD	09b6413H
	DD	09a3413H
	DD	0980113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 033001H
	DD	046830H
	DD	0a207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$frustum_collider@$00$00@@QEAAXK@Z DD 071301H
	DD	09b6413H
	DD	09a3413H
	DD	0980113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z DD 033001H
	DD	046830H
	DD	0a207H
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\Frustum.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\Frustum.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z
_TEXT	SEGMENT
BC$1 = 32
BC$2 = 32
this$ = 96
m_def$ = 104
F$ = 112
?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z PROC ; CDB::COLLIDER::frustum_query, COMDAT

; 81   : {

$LN53:
	mov	QWORD PTR [rsp+32], rbp
	push	rsi
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB.h

; 86   : 			if (S_READY!=status)

	cmp	DWORD PTR [rdx+16], 0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 81   : {

	mov	r14, r8
	mov	QWORD PTR [rsp+104], rdi
	mov	rsi, rcx
	mov	QWORD PTR [rsp+112], r12
	mov	rdi, rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB.h

; 86   : 			if (S_READY!=status)

	je	SHORT $LN10@frustum_qu

; 87   : 			{
; 88   : 				Log						("! WARNING: syncronized CDB::query");
; 89   : 				xrCriticalSection*	C	= (xrCriticalSection*) &cs;
; 90   : 				C->Enter				();

	mov	rcx, rdx
	call	QWORD PTR __imp_?Enter@xrCriticalSection@@QEAAXXZ

; 91   : 				C->Leave				();

	mov	rcx, rdi
	call	QWORD PTR __imp_?Leave@xrCriticalSection@@QEAAXXZ
$LN10@frustum_qu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 86   : 	const AABBNoLeafNode*	N	= T->GetNodes();

	mov	rax, QWORD PTR [rdi+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\Frustum.h

; 82   : 	u32				getMask				() const { return (1<<p_count)-1; }

	mov	ebp, 1
	mov	ecx, DWORD PTR [r14+240]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1361 :         const pointer _Firstptr = _First._Ptr;

	mov	r12, QWORD PTR [rsi+16]

; 1362 :         const pointer _Lastptr  = _Last._Ptr;

	mov	rdx, QWORD PTR [rsi+24]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 86   : 	const AABBNoLeafNode*	N	= T->GetNodes();

	mov	r9, QWORD PTR [rax+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\Frustum.h

; 82   : 	u32				getMask				() const { return (1<<p_count)-1; }

	shl	ebp, cl
	dec	ebp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 86   : 	const AABBNoLeafNode*	N	= T->GetNodes();

	mov	r15, QWORD PTR [r9+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1372 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	cmp	r12, rdx
	je	SHORT $LN31@frustum_qu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	QWORD PTR [rsp+96], rbx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r12
	mov	rbx, rdx
	sub	rbx, rdx
	mov	r8, rbx
	call	memmove

; 3755 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+r12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1377 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+96]
	mov	QWORD PTR [rsi+24], rax
$LN31@frustum_qu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 91   : 	if (frustum_mode&OPT_FULL_TEST) 

	mov	r8, QWORD PTR [rdi+24]
	mov	rdx, r15
	mov	eax, DWORD PTR [rsi+8]
	mov	ecx, eax
	mov	r9, QWORD PTR [rdi+40]
	and	ecx, 2
	mov	r12, QWORD PTR [rsp+112]
	mov	rdi, QWORD PTR [rsp+104]
	mov	QWORD PTR BC$2[rsp+8], r8
	mov	r8d, ebp
	mov	QWORD PTR BC$2[rsp], rsi
	mov	QWORD PTR BC$2[rsp+16], r9
	mov	QWORD PTR BC$2[rsp+24], r14
	test	al, 8
	je	SHORT $LN2@frustum_qu

; 92   : 	{
; 93   : 		if (frustum_mode&OPT_ONLYFIRST)

	test	ecx, ecx
	lea	rcx, QWORD PTR BC$2[rsp]
	je	SHORT $LN4@frustum_qu

; 94   : 		{
; 95   : 			frustum_collider<true,true> BC;
; 96   : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 97   : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,1>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbp, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN4@frustum_qu:

; 98   : 		} else {
; 99   : 			frustum_collider<true,false> BC;
; 100  : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 101  : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,0>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbp, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN2@frustum_qu:

; 102  : 		}
; 103  : 	} else {
; 104  : 		if (frustum_mode&OPT_ONLYFIRST)

	test	ecx, ecx
	lea	rcx, QWORD PTR BC$1[rsp]
	je	SHORT $LN6@frustum_qu

; 105  : 		{
; 106  : 			frustum_collider<false,true> BC;
; 107  : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 108  : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,1>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbp, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
$LN6@frustum_qu:

; 109  : 		} else {
; 110  : 			frustum_collider<false,false> BC;
; 111  : 			BC._init	(this,m_def->verts,m_def->tris,&F);
; 112  : 			BC._stab	(N,mask);

	call	?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,0>::_stab

; 113  : 		}
; 114  : 	}
; 115  : }

	mov	rbp, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	rsi
	ret	0
?frustum_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBVCFrustum@@@Z ENDP ; CDB::COLLIDER::frustum_query
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<0,0>::_stab, COMDAT

; 62   : 	{

$LN32:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 62   : 	{

	mov	rbx, rdx
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rdx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rdx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rdx+16]
	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN7@stab
	npad	10
$LL23@stab:

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [rbx+24]
	mov	rcx, rdi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN3@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z ; frustum_collider<0,0>::_prim
	jmp	SHORT $LN4@stab
$LN3@stab:

; 69   : 		else					_stab	(node->GetPos(),mask);

	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,0>::_stab
$LN4@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN27@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR mask$[rsp]
	mov	rcx, QWORD PTR [rdi+24]
	lea	rdx, QWORD PTR mM$1[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]
	movss	xmm3, DWORD PTR [rbx+8]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rbx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rbx+16]
	movss	DWORD PTR mM$1[rsp+12], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+4], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rbx+20]
	movss	DWORD PTR mM$1[rsp+16], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL23@stab

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN27@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z ; frustum_collider<0,0>::_prim
$LN7@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<0,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<0,0>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<0,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<0,1>::_stab, COMDAT

; 62   : 	{

$LN40:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 62   : 	{

	mov	rbx, rdx
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rdx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rdx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rdx+16]
	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN7@stab
	mov	QWORD PTR [rsp+96], rsi
	mov	rsi, 7905747460161236407		; 6db6db6db6db6db7H
	npad	11
$LL29@stab:

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [rbx+24]
	mov	rcx, rdi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN3@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z ; frustum_collider<0,1>::_prim
	jmp	SHORT $LN4@stab
$LN3@stab:

; 69   : 		else					_stab	(node->GetPos(),mask);

	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<0,1>::_stab
$LN4@stab:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rdi]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 3
	imul	rcx, rsi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 72   : 		if (bFirst && dest->r_count())												return;

	test	ecx, ecx
	jne	$LN38@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN34@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR mask$[rsp]
	mov	rcx, QWORD PTR [rdi+24]
	lea	rdx, QWORD PTR mM$1[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]
	movss	xmm3, DWORD PTR [rbx+8]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rbx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rbx+16]
	movss	DWORD PTR mM$1[rsp+12], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+4], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rbx+20]
	movss	DWORD PTR mM$1[rsp+16], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL29@stab
	jmp	SHORT $LN38@stab
$LN34@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z ; frustum_collider<0,1>::_prim
$LN38@stab:
	mov	rsi, QWORD PTR [rsp+96]
$LN7@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+104]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<0,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<0,1>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<0,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<1,0>::_stab, COMDAT

; 62   : 	{

$LN32:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 62   : 	{

	mov	rbx, rdx
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rdx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rdx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rdx+16]
	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN7@stab
	npad	10
$LL23@stab:

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [rbx+24]
	mov	rcx, rdi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN3@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z ; frustum_collider<1,0>::_prim
	jmp	SHORT $LN4@stab
$LN3@stab:

; 69   : 		else					_stab	(node->GetPos(),mask);

	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,0>::_stab
$LN4@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN27@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR mask$[rsp]
	mov	rcx, QWORD PTR [rdi+24]
	lea	rdx, QWORD PTR mM$1[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]
	movss	xmm3, DWORD PTR [rbx+8]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rbx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rbx+16]
	movss	DWORD PTR mM$1[rsp+12], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+4], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rbx+20]
	movss	DWORD PTR mM$1[rsp+16], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL23@stab

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
$LN27@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z ; frustum_collider<1,0>::_prim
$LN7@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+96]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<1,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<1,0>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<1,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z
_TEXT	SEGMENT
mM$1 = 32
this$ = 96
node$ = 104
mask$ = 112
?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z PROC ; frustum_collider<1,1>::_stab, COMDAT

; 62   : 	{

$LN40:
	mov	rax, rsp
	mov	QWORD PTR [rax+16], rbx
	mov	DWORD PTR [rax+24], r8d
	push	rdi
	sub	rsp, 80					; 00000050H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR [rax+24]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 62   : 	{

	mov	rbx, rdx
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	rdi, rcx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rdx+12]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rdx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rdx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rdx+16]
	movss	DWORD PTR [rax-44], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	je	$LN7@stab
	mov	QWORD PTR [rsp+96], rsi
	mov	rsi, 7905747460161236407		; 6db6db6db6db6db7H
	npad	11
$LL29@stab:

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [rbx+24]
	mov	rcx, rdi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN3@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 68   : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$frustum_collider@$00$00@@QEAAXK@Z ; frustum_collider<1,1>::_prim
	jmp	SHORT $LN4@stab
$LN3@stab:

; 69   : 		else					_stab	(node->GetPos(),mask);

	mov	r8d, DWORD PTR mask$[rsp]
	call	?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ; frustum_collider<1,1>::_stab
$LN4@stab:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rdi]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 3
	imul	rcx, rsi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 72   : 		if (bFirst && dest->r_count())												return;

	test	ecx, ecx
	jne	$LN38@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rbx+32], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	SHORT $LN34@stab

; 76   : 		else					_stab	(node->GetNeg(),mask);

	mov	rbx, QWORD PTR [rbx+32]

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	r8, QWORD PTR mask$[rsp]
	mov	rcx, QWORD PTR [rdi+24]
	lea	rdx, QWORD PTR mM$1[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [rbx]
	movss	xmm5, DWORD PTR [rbx+4]
	movaps	xmm0, xmm6
	subss	xmm0, DWORD PTR [rbx+12]
	movss	xmm3, DWORD PTR [rbx+8]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, DWORD PTR [rbx+12]

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp], xmm0
	movaps	xmm0, xmm5
	subss	xmm0, DWORD PTR [rbx+16]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, DWORD PTR [rbx+16]
	movss	DWORD PTR mM$1[rsp+12], xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+4], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, DWORD PTR [rbx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, DWORD PTR [rbx+20]
	movss	DWORD PTR mM$1[rsp+16], xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+8], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR mM$1[rsp+20], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 63   : 		// Actual frustum/aabb test
; 64   : 		EFC_Visible	result		= _box((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,mask);
; 65   : 		if (fcvNone == result)	return;

	test	eax, eax
	jne	$LL29@stab
	jmp	SHORT $LN38@stab
$LN34@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rdi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 75   : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$frustum_collider@$00$00@@QEAAXK@Z ; frustum_collider<1,1>::_prim
$LN38@stab:
	mov	rsi, QWORD PTR [rsp+96]
$LN7@stab:

; 77   : 	}

	mov	rbx, QWORD PTR [rsp+104]
	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?_stab@?$frustum_collider@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@I@Z ENDP ; frustum_collider<1,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
_F$ = 40
?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z PROC ; frustum_collider<1,1>::_init, COMDAT

; 22   : 		dest		= CL;
; 23   : 		tris		= T;
; 24   : 		verts		= V;
; 25   : 		F			= _F;

	mov	rax, QWORD PTR _F$[rsp]
	mov	QWORD PTR [rcx+24], rax
	mov	QWORD PTR [rcx], rdx
	mov	QWORD PTR [rcx+8], r9
	mov	QWORD PTR [rcx+16], r8

; 26   : 	}

	ret	0
?_init@?$frustum_collider@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@PEBVCFrustum@@@Z ENDP ; frustum_collider<1,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z
_TEXT	SEGMENT
this$ = 48
prim$ = 56
?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z PROC	; frustum_collider<0,0>::_prim, COMDAT

; 35   : 	{

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	ebx, edx

; 36   : 		if (bClass3)	{
; 37   : 			sPoly		src,dst;
; 38   : 			src.resize	(3);
; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];
; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))
; 43   : 			{
; 44   : 				RESULT& R	= dest->r_add();
; 45   : 				R.id		= prim;
; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];
; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];
; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];
; 49   : 				R.dummy		= tris[prim].dummy;
; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rcx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 53   : 			R.id		= prim;
; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	r8, QWORD PTR [rdi+16]
	mov	r10, rax
	mov	r9d, ebx
	shl	r9, 4
	add	r9, QWORD PTR [rdi+8]
	mov	DWORD PTR [rax+40], ebx

; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	ecx, DWORD PTR [r9]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [r8+rdx*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [rax+8], ecx
	mov	eax, DWORD PTR [r9+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r8+rcx*4]
	movsd	QWORD PTR [r10+12], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+20], eax
	mov	eax, DWORD PTR [r9+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r8+rcx*4]
	movsd	QWORD PTR [r10+24], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+32], eax
	mov	eax, DWORD PTR [r9+12]
	mov	DWORD PTR [r10+36], eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$0A@$0A@@@QEAAXK@Z ENDP	; frustum_collider<0,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<0,0>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	xmm0, xmm5
	movss	xmm4, DWORD PTR [r8+4]
	movss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [r8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	r8, r9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6
	addss	xmm4, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0
	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm4
	addss	xmm2, xmm1

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$0A@$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<0,0>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z
_TEXT	SEGMENT
this$ = 48
prim$ = 56
?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z PROC	; frustum_collider<0,1>::_prim, COMDAT

; 35   : 	{

$LN26:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx
	mov	ebx, edx

; 36   : 		if (bClass3)	{
; 37   : 			sPoly		src,dst;
; 38   : 			src.resize	(3);
; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];
; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))
; 43   : 			{
; 44   : 				RESULT& R	= dest->r_add();
; 45   : 				R.id		= prim;
; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];
; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];
; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];
; 49   : 				R.dummy		= tris[prim].dummy;
; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rcx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 53   : 			R.id		= prim;
; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	r8, QWORD PTR [rdi+16]
	mov	r10, rax
	mov	r9d, ebx
	shl	r9, 4
	add	r9, QWORD PTR [rdi+8]
	mov	DWORD PTR [rax+40], ebx

; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	mov	rbx, QWORD PTR [rsp+48]
	mov	ecx, DWORD PTR [r9]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [r8+rdx*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [rax+8], ecx
	mov	eax, DWORD PTR [r9+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r8+rcx*4]
	movsd	QWORD PTR [r10+12], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+20], eax
	mov	eax, DWORD PTR [r9+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r8+rcx*4]
	movsd	QWORD PTR [r10+24], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+32], eax
	mov	eax, DWORD PTR [r9+12]
	mov	DWORD PTR [r10+36], eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$0A@$00@@QEAAXK@Z ENDP	; frustum_collider<0,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<0,1>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	xmm0, xmm5
	movss	xmm4, DWORD PTR [r8+4]
	movss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [r8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	r8, r9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6
	addss	xmm4, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0
	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm4
	addss	xmm2, xmm1

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$0A@$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<0,1>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\FixedVector.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z
_TEXT	SEGMENT
src$1 = 32
dst$2 = 624
this$ = 1232
prim$ = 1240
?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z PROC	; frustum_collider<1,0>::_prim, COMDAT

; 35   : 	{

$LN26:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 1216				; 000004c0H

; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	mov	r10, QWORD PTR [rcx+16]
	mov	rbx, rcx
	mov	r9, QWORD PTR [rcx+8]
	mov	DWORD PTR [rax-616], 3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\FixedVector.h

; 21   :     svector() : count(0)

	mov	DWORD PTR [rax-24], 0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	mov	edi, edx
	shl	rdi, 4
	mov	esi, edx

; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))

	lea	rdx, QWORD PTR src$1[rsp]
	mov	eax, DWORD PTR [r9+rdi]
	lea	r8, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r10+r8*4]
	movsd	QWORD PTR src$1[rsp], xmm0
	mov	eax, DWORD PTR [r10+r8*4+8]
	lea	r8, QWORD PTR dst$2[rsp]
	mov	DWORD PTR src$1[rsp+8], eax
	mov	eax, DWORD PTR [r9+rdi+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r10+rcx*4]
	movsd	QWORD PTR src$1[rsp+12], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	DWORD PTR src$1[rsp+20], eax
	mov	eax, DWORD PTR [r9+rdi+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r10+rcx*4]
	movsd	QWORD PTR src$1[rsp+24], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	rcx, QWORD PTR [rbx+24]
	mov	DWORD PTR src$1[rsp+32], eax
	call	?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z ; CFrustum::ClipPoly
	test	rax, rax
	je	SHORT $LN4@prim

; 43   : 			{
; 44   : 				RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 45   : 				R.id		= prim;
; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	r8, QWORD PTR [rbx+16]
	mov	r10, rax
	mov	r9, QWORD PTR [rbx+8]
	add	r9, rdi
	mov	DWORD PTR [rax+40], esi
	mov	ecx, DWORD PTR [r9]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [r8+rdx*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [rax+8], ecx

; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];

	mov	ecx, DWORD PTR [r9+4]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [r8+rdx*4]
	movsd	QWORD PTR [rax+12], xmm0
	mov	eax, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [r10+20], eax

; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];

	mov	eax, DWORD PTR [r9+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r8+rcx*4]
	movsd	QWORD PTR [r10+24], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+32], eax

; 49   : 				R.dummy		= tris[prim].dummy;

	mov	eax, DWORD PTR [r9+12]
	mov	DWORD PTR [r10+36], eax
$LN4@prim:

; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();
; 53   : 			R.id		= prim;
; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];
; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	lea	r11, QWORD PTR [rsp+1216]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$00$0A@@@QEAAXK@Z ENDP	; frustum_collider<1,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<1,0>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	xmm0, xmm5
	movss	xmm4, DWORD PTR [r8+4]
	movss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [r8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	r8, r9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6
	addss	xmm4, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0
	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm4
	addss	xmm2, xmm1

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$00$0A@@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<1,0>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\FixedVector.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_prim@?$frustum_collider@$00$00@@QEAAXK@Z
_TEXT	SEGMENT
src$1 = 32
dst$2 = 624
this$ = 1232
prim$ = 1240
?_prim@?$frustum_collider@$00$00@@QEAAXK@Z PROC		; frustum_collider<1,1>::_prim, COMDAT

; 35   : 	{

$LN26:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 1216				; 000004c0H

; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	mov	r10, QWORD PTR [rcx+16]
	mov	rbx, rcx
	mov	r9, QWORD PTR [rcx+8]
	mov	DWORD PTR [rax-616], 3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\FixedVector.h

; 21   :     svector() : count(0)

	mov	DWORD PTR [rax-24], 0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 39   : 			src[0]		= verts[ tris[prim].verts[0] ];

	mov	edi, edx
	shl	rdi, 4
	mov	esi, edx

; 40   : 			src[1]		= verts[ tris[prim].verts[1] ];
; 41   : 			src[2]		= verts[ tris[prim].verts[2] ];
; 42   : 			if (F->ClipPoly(src,dst))

	lea	rdx, QWORD PTR src$1[rsp]
	mov	eax, DWORD PTR [r9+rdi]
	lea	r8, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r10+r8*4]
	movsd	QWORD PTR src$1[rsp], xmm0
	mov	eax, DWORD PTR [r10+r8*4+8]
	lea	r8, QWORD PTR dst$2[rsp]
	mov	DWORD PTR src$1[rsp+8], eax
	mov	eax, DWORD PTR [r9+rdi+4]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r10+rcx*4]
	movsd	QWORD PTR src$1[rsp+12], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	DWORD PTR src$1[rsp+20], eax
	mov	eax, DWORD PTR [r9+rdi+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r10+rcx*4]
	movsd	QWORD PTR src$1[rsp+24], xmm0
	mov	eax, DWORD PTR [r10+rcx*4+8]
	mov	rcx, QWORD PTR [rbx+24]
	mov	DWORD PTR src$1[rsp+32], eax
	call	?ClipPoly@CFrustum@@QEBAPEAV?$svector@U?$_vector3@M@@$0DA@@@AEAV2@0@Z ; CFrustum::ClipPoly
	test	rax, rax
	je	SHORT $LN4@prim

; 43   : 			{
; 44   : 				RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add

; 45   : 				R.id		= prim;
; 46   : 				R.verts[0]	= verts[ tris[prim].verts[0] ];

	mov	r8, QWORD PTR [rbx+16]
	mov	r10, rax
	mov	r9, QWORD PTR [rbx+8]
	add	r9, rdi
	mov	DWORD PTR [rax+40], esi
	mov	ecx, DWORD PTR [r9]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [r8+rdx*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [rax+8], ecx

; 47   : 				R.verts[1]	= verts[ tris[prim].verts[1] ];

	mov	ecx, DWORD PTR [r9+4]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [r8+rdx*4]
	movsd	QWORD PTR [rax+12], xmm0
	mov	eax, DWORD PTR [r8+rdx*4+8]
	mov	DWORD PTR [r10+20], eax

; 48   : 				R.verts[2]	= verts[ tris[prim].verts[2] ];

	mov	eax, DWORD PTR [r9+8]
	lea	rcx, QWORD PTR [rax+rax*2]
	movsd	xmm0, QWORD PTR [r8+rcx*4]
	movsd	QWORD PTR [r10+24], xmm0
	mov	eax, DWORD PTR [r8+rcx*4+8]
	mov	DWORD PTR [r10+32], eax

; 49   : 				R.dummy		= tris[prim].dummy;

	mov	eax, DWORD PTR [r9+12]
	mov	DWORD PTR [r10+36], eax
$LN4@prim:

; 50   : 			}
; 51   : 		} else {
; 52   : 			RESULT& R	= dest->r_add();
; 53   : 			R.id		= prim;
; 54   : 			R.verts[0]	= verts[ tris[prim].verts[0] ];
; 55   : 			R.verts[1]	= verts[ tris[prim].verts[1] ];
; 56   : 			R.verts[2]	= verts[ tris[prim].verts[2] ];
; 57   : 			R.dummy		= tris[prim].dummy;
; 58   : 		}
; 59   : 	}

	lea	r11, QWORD PTR [rsp+1216]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$frustum_collider@$00$00@@QEAAXK@Z ENDP		; frustum_collider<1,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp
;	COMDAT ?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z
_TEXT	SEGMENT
this$ = 96
C$ = 104
E$ = 112
mask$ = 120
?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z PROC ; frustum_collider<1,1>::_box, COMDAT

; 28   : 	{

$LN8:
	mov	rax, rsp
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rdx]
	movss	xmm3, DWORD PTR [rdx+4]
	movaps	xmm0, xmm5
	movss	xmm4, DWORD PTR [r8+4]
	movss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	lea	rdx, QWORD PTR [rax-56]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [r8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	rcx, QWORD PTR [rcx+24]
	movaps	XMMWORD PTR [rax-24], xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	mov	r8, r9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm0, xmm6

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm6, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-56], xmm0
	movaps	xmm0, xmm3
	subss	xmm0, xmm4

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-44], xmm6
	addss	xmm4, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-52], xmm0
	movaps	xmm0, xmm1
	subss	xmm0, xmm2

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-40], xmm4
	addss	xmm2, xmm1

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR [rax-48], xmm0

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	movss	DWORD PTR [rax-36], xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_frustum.cpp

; 32   : 		return F->testAABB		(&mM[0].x,mask);

	call	?testAABB@CFrustum@@QEBA?AW4EFC_Visible@@PEBMAEAI@Z ; CFrustum::testAABB

; 33   : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	add	rsp, 88					; 00000058H
	ret	0
?_box@?$frustum_collider@$00$00@@QEAA?AW4EFC_Visible@@AEAU?$_vector3@M@@0AEAI@Z ENDP ; frustum_collider<1,1>::_box
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\FixedVector.h
;	COMDAT ?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 8
c$dead$ = 16
?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z PROC	; svector<_vector3<float>,48>::resize, COMDAT

; 34   :     IC void resize(int c) { VERIFY(c <= dim); count = c; }

	mov	DWORD PTR [rcx+576], 3
	ret	0
?resize@?$svector@U?$_vector3@M@@$0DA@@@QEAAXH@Z ENDP	; svector<_vector3<float>,48>::resize
_TEXT	ENDS
END
