; Listing generated by Microsoft (R) Optimizing Compiler Version 19.26.28806.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,1,1>::_tri
PUBLIC	?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,1,0>::_tri
PUBLIC	?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,0,1>::_tri
PUBLIC	?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,1,0,0>::_tri
PUBLIC	?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,1,1>::_tri
PUBLIC	?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,1,0>::_tri
PUBLIC	?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,0,1>::_tri
PUBLIC	?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<1,0,0,0>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,1,1>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,1,0>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,0,1>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,1,0,0>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,1,1>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,1,0>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,0,1>::_tri
PUBLIC	?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z ; ray_collider<0,0,0,0>::_tri
PUBLIC	?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,1,1,1>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,1,1,1>::_box_sse
PUBLIC	?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z	; ray_collider<1,1,1,1>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,1,1,0>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,1,1,0>::_box_sse
PUBLIC	?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z	; ray_collider<1,1,1,0>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,1,0,1>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,1,0,1>::_box_sse
PUBLIC	?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z	; ray_collider<1,1,0,1>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,1,0,0>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,1,0,0>::_box_sse
PUBLIC	?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z	; ray_collider<1,1,0,0>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,0,1,1>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,0,1,1>::_box_sse
PUBLIC	?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z	; ray_collider<1,0,1,1>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,0,1,0>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,0,1,0>::_box_sse
PUBLIC	?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z	; ray_collider<1,0,1,0>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,0,0,1>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,0,0,1>::_box_sse
PUBLIC	?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z	; ray_collider<1,0,0,1>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<1,0,0,0>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<1,0,0,0>::_box_sse
PUBLIC	?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z	; ray_collider<1,0,0,0>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,1,1,1>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,1,1,1>::_box_sse
PUBLIC	?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z	; ray_collider<0,1,1,1>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,1,1,0>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,1,1,0>::_box_sse
PUBLIC	?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z	; ray_collider<0,1,1,0>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,1,0,1>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,1,0,1>::_box_sse
PUBLIC	?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z	; ray_collider<0,1,0,1>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,1,0,0>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,1,0,0>::_box_sse
PUBLIC	?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z	; ray_collider<0,1,0,0>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,0,1,1>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,0,1,1>::_box_sse
PUBLIC	?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z	; ray_collider<0,0,1,1>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,0,1,0>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,0,1,0>::_box_sse
PUBLIC	?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z	; ray_collider<0,0,1,0>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,0,0,1>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,0,0,1>::_box_sse
PUBLIC	?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z	; ray_collider<0,0,0,1>::_prim
PUBLIC	?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ; ray_collider<0,0,0,0>::_box_fpu
PUBLIC	?_box_sse@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ; ray_collider<0,0,0,0>::_box_sse
PUBLIC	?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z ; ray_collider<0,0,0,0>::_prim
PUBLIC	?_init@?$ray_collider@$00$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,1,1,1>::_init
PUBLIC	?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,1>::_stab
PUBLIC	?_init@?$ray_collider@$00$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,1,1,0>::_init
PUBLIC	?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,0>::_stab
PUBLIC	?_init@?$ray_collider@$00$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,1,0,1>::_init
PUBLIC	?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,1>::_stab
PUBLIC	?_init@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,1,0,0>::_init
PUBLIC	?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,0>::_stab
PUBLIC	?_init@?$ray_collider@$00$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,0,1,1>::_init
PUBLIC	?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,1>::_stab
PUBLIC	?_init@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,0,1,0>::_init
PUBLIC	?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,0>::_stab
PUBLIC	?_init@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,0,0,1>::_init
PUBLIC	?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,1>::_stab
PUBLIC	?_init@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<1,0,0,0>::_init
PUBLIC	?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,0>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,1,1,1>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,1>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,1,1,0>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,0>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,1,0,1>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,1>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,1,0,0>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,0>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,0,1,1>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,1>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,0,1,0>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,0>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,0,0,1>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,1>::_stab
PUBLIC	?_init@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ; ray_collider<0,0,0,0>::_init
PUBLIC	?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,0>::_stab
PUBLIC	?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z ; CDB::COLLIDER::ray_query
?flt_plus_inf@@3MB DD 01H DUP (?)			; flt_plus_inf
?ps_cst_plus_inf@@3QBMB DD 04H DUP (?)			; ps_cst_plus_inf
?ps_cst_minus_inf@@3QBMB DD 04H DUP (?)			; ps_cst_minus_inf
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+627
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+627
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+627
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+627
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+626
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+626
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+626
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+626
	DD	imagerel $unwind$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+627
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+627
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+627
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+627
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+626
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+626
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+626
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD imagerel $LN44
	DD	imagerel $LN44+626
	DD	imagerel $unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD imagerel $LN64+358
	DD	imagerel $LN64+989
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD imagerel $LN64+989
	DD	imagerel $LN64+1051
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z DD imagerel $LN61
	DD	imagerel $LN61+804
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD imagerel $LN64+358
	DD	imagerel $LN64+989
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD imagerel $LN64+989
	DD	imagerel $LN64+1051
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z DD imagerel $LN61
	DD	imagerel $LN61+804
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+1064
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN64+352
	DD	imagerel $LN64+785
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN64+785
	DD	imagerel $LN64+853
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+1064
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN64+352
	DD	imagerel $LN64+785
	DD	imagerel $chain$0$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN64+785
	DD	imagerel $LN64+853
	DD	imagerel $chain$1$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD imagerel $LN64+358
	DD	imagerel $LN64+989
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD imagerel $LN64+989
	DD	imagerel $LN64+1051
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z DD imagerel $LN61
	DD	imagerel $LN61+804
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD imagerel $LN64+358
	DD	imagerel $LN64+989
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD imagerel $LN64+989
	DD	imagerel $LN64+1051
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z DD imagerel $LN61
	DD	imagerel $LN61+804
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+1064
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN64+352
	DD	imagerel $LN64+785
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD imagerel $LN64+785
	DD	imagerel $LN64+853
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+1064
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD imagerel $LN264
	DD	imagerel $LN264+630
	DD	imagerel $unwind$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN64+352
	DD	imagerel $LN64+785
	DD	imagerel $chain$0$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD imagerel $LN64+785
	DD	imagerel $LN64+853
	DD	imagerel $chain$1$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302+193
	DD	imagerel $LN302+481
	DD	imagerel $chain$0$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302+481
	DD	imagerel $LN302+497
	DD	imagerel $chain$1$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302+193
	DD	imagerel $LN302+481
	DD	imagerel $chain$0$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302+481
	DD	imagerel $LN302+497
	DD	imagerel $chain$1$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN294
	DD	imagerel $LN294+464
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN294
	DD	imagerel $LN294+464
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302+193
	DD	imagerel $LN302+481
	DD	imagerel $chain$0$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302+481
	DD	imagerel $LN302+497
	DD	imagerel $chain$1$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302+193
	DD	imagerel $LN302+481
	DD	imagerel $chain$0$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN302+481
	DD	imagerel $LN302+497
	DD	imagerel $chain$1$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN294
	DD	imagerel $LN294+464
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN294
	DD	imagerel $LN294+464
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN308
	DD	imagerel $LN308+911
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN308
	DD	imagerel $LN308+911
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN301
	DD	imagerel $LN301+857
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN301
	DD	imagerel $LN301+857
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN308
	DD	imagerel $LN308+911
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN308
	DD	imagerel $LN308+911
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN301
	DD	imagerel $LN301+857
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD imagerel $LN301
	DD	imagerel $LN301+857
	DD	imagerel $unwind$?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD imagerel $LN1550
	DD	imagerel $LN1550+47
	DD	imagerel $unwind$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD imagerel $LN1550+47
	DD	imagerel $LN1550+110
	DD	imagerel $chain$2$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD imagerel $LN1550+110
	DD	imagerel $LN1550+151
	DD	imagerel $chain$3$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD imagerel $LN1550+151
	DD	imagerel $LN1550+338
	DD	imagerel $chain$6$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD imagerel $LN1550+338
	DD	imagerel $LN1550+541
	DD	imagerel $chain$7$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD imagerel $LN1550+541
	DD	imagerel $LN1550+1134
	DD	imagerel $chain$9$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD imagerel $LN1550+1134
	DD	imagerel $LN1550+1184
	DD	imagerel $chain$10$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eflt_plus_inf@@YAXXZ DD imagerel ??__Eflt_plus_inf@@YAXXZ
	DD	imagerel ??__Eflt_plus_inf@@YAXXZ+32
	DD	imagerel $unwind$??__Eflt_plus_inf@@YAXXZ
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eflt_plus_inf@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD 021H
	DD	imagerel $LN1550+338
	DD	imagerel $LN1550+541
	DD	imagerel $chain$7$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD 041621H
	DD	08c816H
	DD	09b809H
	DD	imagerel $LN1550+338
	DD	imagerel $LN1550+541
	DD	imagerel $chain$7$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD 040021H
	DD	0aa800H
	DD	0b9800H
	DD	imagerel $LN1550
	DD	imagerel $LN1550+47
	DD	imagerel $unwind$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD 046021H
	DD	0aa860H
	DD	0b9857H
	DD	imagerel $LN1550+47
	DD	imagerel $LN1550+110
	DD	imagerel $chain$2$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD 020821H
	DD	0243408H
	DD	imagerel $LN1550+47
	DD	imagerel $LN1550+110
	DD	imagerel $chain$2$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD 060f21H
	DD	01ee40fH
	DD	026d408H
	DD	025c404H
	DD	imagerel $LN1550
	DD	imagerel $LN1550+47
	DD	imagerel $unwind$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z DD 0c2f01H
	DD	0c882fH
	DD	0d782aH
	DD	0e681eH
	DD	01f0113H
	DD	07006f008H
	DD	050046005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6801H
	DD	04f868H
	DD	05e862H
	DD	06d85cH
	DD	07c856H
	DD	08b851H
	DD	09a84cH
	DD	0a9847H
	DD	0b8838H
	DD	0c782dH
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6801H
	DD	04f868H
	DD	05e862H
	DD	06d85cH
	DD	07c856H
	DD	08b851H
	DD	09a84cH
	DD	0a9847H
	DD	0b8838H
	DD	0c782dH
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01f7801H
	DD	04f878H
	DD	05e872H
	DD	06d86cH
	DD	07c866H
	DD	08b861H
	DD	09a85cH
	DD	0a9857H
	DD	0b8847H
	DD	0c7832H
	DD	0d6820H
	DD	021741cH
	DD	020641cH
	DD	01f541cH
	DD	01e341cH
	DD	01c011cH
	DD	0e015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01f7801H
	DD	04f878H
	DD	05e872H
	DD	06d86cH
	DD	07c866H
	DD	08b861H
	DD	09a85cH
	DD	0a9857H
	DD	0b8847H
	DD	0c7832H
	DD	0d6820H
	DD	021741cH
	DD	020641cH
	DD	01f541cH
	DD	01e341cH
	DD	01c011cH
	DD	0e015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6801H
	DD	04f868H
	DD	05e862H
	DD	06d85cH
	DD	07c856H
	DD	08b851H
	DD	09a84cH
	DD	0a9847H
	DD	0b8838H
	DD	0c782dH
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01d6801H
	DD	04f868H
	DD	05e862H
	DD	06d85cH
	DD	07c856H
	DD	08b851H
	DD	09a84cH
	DD	0a9847H
	DD	0b8838H
	DD	0c782dH
	DD	0d681bH
	DD	0206417H
	DD	01f5417H
	DD	01e3417H
	DD	01c0117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01f7801H
	DD	04f878H
	DD	05e872H
	DD	06d86cH
	DD	07c866H
	DD	08b861H
	DD	09a85cH
	DD	0a9857H
	DD	0b8847H
	DD	0c7832H
	DD	0d6820H
	DD	021741cH
	DD	020641cH
	DD	01f541cH
	DD	01e341cH
	DD	01c011cH
	DD	0e015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 01f7801H
	DD	04f878H
	DD	05e872H
	DD	06d86cH
	DD	07c866H
	DD	08b861H
	DD	09a85cH
	DD	0a9857H
	DD	0b8847H
	DD	0c7832H
	DD	0d6820H
	DD	021741cH
	DD	020641cH
	DD	01f541cH
	DD	01e341cH
	DD	01c011cH
	DD	0e015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 061701H
	DD	026817H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 061701H
	DD	026817H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 021H
	DD	imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 020521H
	DD	086405H
	DD	imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 061701H
	DD	026817H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 021H
	DD	imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 020521H
	DD	086405H
	DD	imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 061701H
	DD	026817H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 061701H
	DD	026817H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 061701H
	DD	026817H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 021H
	DD	imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 020521H
	DD	086405H
	DD	imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 061701H
	DD	026817H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 021H
	DD	imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 020521H
	DD	086405H
	DD	imagerel $LN302
	DD	imagerel $LN302+193
	DD	imagerel $unwind$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z DD 061701H
	DD	026817H
	DD	09340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD 020621H
	DD	06b806H
	DD	imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z DD 0195901H
	DD	02f859H
	DD	03e84cH
	DD	04d846H
	DD	05c840H
	DD	07a83bH
	DD	089836H
	DD	09882bH
	DD	0a7826H
	DD	0b6822H
	DD	01d6413H
	DD	01c3413H
	DD	0180113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z DD 0196b01H
	DD	02f86bH
	DD	03e865H
	DD	04d85aH
	DD	05c850H
	DD	06b844H
	DD	07a839H
	DD	089830H
	DD	098825H
	DD	0a7820H
	DD	0b681cH
	DD	018010dH
	DD	060057006H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD 020621H
	DD	06b806H
	DD	imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z DD 0195901H
	DD	02f859H
	DD	03e84cH
	DD	04d846H
	DD	05c840H
	DD	07a83bH
	DD	089836H
	DD	09882bH
	DD	0a7826H
	DD	0b6822H
	DD	01d6413H
	DD	01c3413H
	DD	0180113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z DD 0196b01H
	DD	02f86bH
	DD	03e865H
	DD	04d85aH
	DD	05c850H
	DD	06b844H
	DD	07a839H
	DD	089830H
	DD	098825H
	DD	0a7820H
	DD	0b681cH
	DD	018010dH
	DD	060057006H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z DD 01b5e01H
	DD	02f85eH
	DD	03e856H
	DD	04d84bH
	DD	05c845H
	DD	06b840H
	DD	07a83bH
	DD	089836H
	DD	09882bH
	DD	0a7826H
	DD	0b6822H
	DD	01b6413H
	DD	01a3413H
	DD	0180113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD 020521H
	DD	089805H
	DD	imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z DD 0176801H
	DD	02f868H
	DD	03e862H
	DD	04d84dH
	DD	05c841H
	DD	06b83bH
	DD	07a832H
	DD	098827H
	DD	0a7822H
	DD	0b681dH
	DD	018010dH
	DD	060057006H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z DD 01b5e01H
	DD	02f85eH
	DD	03e856H
	DD	04d84bH
	DD	05c845H
	DD	06b840H
	DD	07a83bH
	DD	089836H
	DD	09882bH
	DD	0a7826H
	DD	0b6822H
	DD	01b6413H
	DD	01a3413H
	DD	0180113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD 020521H
	DD	089805H
	DD	imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z DD 0176801H
	DD	02f868H
	DD	03e862H
	DD	04d84dH
	DD	05c841H
	DD	06b83bH
	DD	07a832H
	DD	098827H
	DD	0a7822H
	DD	0b681dH
	DD	018010dH
	DD	060057006H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD 020621H
	DD	06b806H
	DD	imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z DD 0195901H
	DD	02f859H
	DD	03e84cH
	DD	04d846H
	DD	05c840H
	DD	07a83bH
	DD	089836H
	DD	09882bH
	DD	0a7826H
	DD	0b6822H
	DD	01d6413H
	DD	01c3413H
	DD	0180113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z DD 0196b01H
	DD	02f86bH
	DD	03e865H
	DD	04d85aH
	DD	05c850H
	DD	06b844H
	DD	07a839H
	DD	089830H
	DD	098825H
	DD	0a7820H
	DD	0b681cH
	DD	018010dH
	DD	060057006H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD 020621H
	DD	06b806H
	DD	imagerel $LN64
	DD	imagerel $LN64+352
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z DD 0195901H
	DD	02f859H
	DD	03e84cH
	DD	04d846H
	DD	05c840H
	DD	07a83bH
	DD	089836H
	DD	09882bH
	DD	0a7826H
	DD	0b6822H
	DD	01d6413H
	DD	01c3413H
	DD	0180113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z DD 0196b01H
	DD	02f86bH
	DD	03e865H
	DD	04d85aH
	DD	05c850H
	DD	06b844H
	DD	07a839H
	DD	089830H
	DD	098825H
	DD	0a7820H
	DD	0b681cH
	DD	018010dH
	DD	060057006H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z DD 01b5e01H
	DD	02f85eH
	DD	03e856H
	DD	04d84bH
	DD	05c845H
	DD	06b840H
	DD	07a83bH
	DD	089836H
	DD	09882bH
	DD	0a7826H
	DD	0b6822H
	DD	01b6413H
	DD	01a3413H
	DD	0180113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD 020521H
	DD	089805H
	DD	imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z DD 0176801H
	DD	02f868H
	DD	03e862H
	DD	04d84dH
	DD	05c841H
	DD	06b83bH
	DD	07a832H
	DD	098827H
	DD	0a7822H
	DD	0b681dH
	DD	018010dH
	DD	060057006H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z DD 01b5e01H
	DD	02f85eH
	DD	03e856H
	DD	04d84bH
	DD	05c845H
	DD	06b840H
	DD	07a83bH
	DD	089836H
	DD	09882bH
	DD	0a7826H
	DD	0b6822H
	DD	01b6413H
	DD	01a3413H
	DD	0180113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD 020521H
	DD	089805H
	DD	imagerel $LN64
	DD	imagerel $LN64+358
	DD	imagerel $unwind$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z DD 0176801H
	DD	02f868H
	DD	03e862H
	DD	04d84dH
	DD	05c841H
	DD	06b83bH
	DD	07a832H
	DD	098827H
	DD	0a7822H
	DD	0b681dH
	DD	018010dH
	DD	060057006H
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z DD 095c01H
	DD	01985cH
	DD	028841H
	DD	037837H
	DD	04682fH
	DD	0a204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 0153d01H
	DD	0f83dH
	DD	01e838H
	DD	02d830H
	DD	03c82bH
	DD	04b826H
	DD	05a821H
	DD	06981cH
	DD	077817H
	DD	086813H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD 0153d01H
	DD	0f83dH
	DD	01e838H
	DD	02d830H
	DD	03c82bH
	DD	04b826H
	DD	05a821H
	DD	06981cH
	DD	077817H
	DD	086813H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD 0153d01H
	DD	0f83dH
	DD	01e838H
	DD	02d830H
	DD	03c82bH
	DD	04b826H
	DD	05a821H
	DD	06981cH
	DD	077817H
	DD	086813H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD 0153d01H
	DD	0f83dH
	DD	01e838H
	DD	02d830H
	DD	03c82bH
	DD	04b826H
	DD	05a821H
	DD	06981cH
	DD	077817H
	DD	086813H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 0174301H
	DD	0f843H
	DD	01e83eH
	DD	02d838H
	DD	03c830H
	DD	04b82bH
	DD	05a826H
	DD	069821H
	DD	07881cH
	DD	087817H
	DD	096813H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z DD 0174301H
	DD	0f843H
	DD	01e83eH
	DD	02d838H
	DD	03c830H
	DD	04b82bH
	DD	05a826H
	DD	069821H
	DD	07881cH
	DD	087817H
	DD	096813H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z DD 0174301H
	DD	0f843H
	DD	01e83eH
	DD	02d838H
	DD	03c830H
	DD	04b82bH
	DD	05a826H
	DD	069821H
	DD	07881cH
	DD	087817H
	DD	096813H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z DD 0174301H
	DD	0f843H
	DD	01e83eH
	DD	02d838H
	DD	03c830H
	DD	04b82bH
	DD	05a826H
	DD	069821H
	DD	07881cH
	DD	087817H
	DD	096813H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 0153d01H
	DD	0f83dH
	DD	01e838H
	DD	02d830H
	DD	03c82bH
	DD	04b826H
	DD	05a821H
	DD	06981cH
	DD	077817H
	DD	086813H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z DD 0153d01H
	DD	0f83dH
	DD	01e838H
	DD	02d830H
	DD	03c82bH
	DD	04b826H
	DD	05a821H
	DD	06981cH
	DD	077817H
	DD	086813H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z DD 0153d01H
	DD	0f83dH
	DD	01e838H
	DD	02d830H
	DD	03c82bH
	DD	04b826H
	DD	05a821H
	DD	06981cH
	DD	077817H
	DD	086813H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z DD 0153d01H
	DD	0f83dH
	DD	01e838H
	DD	02d830H
	DD	03c82bH
	DD	04b826H
	DD	05a821H
	DD	06981cH
	DD	077817H
	DD	086813H
	DD	012010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z DD 0174301H
	DD	0f843H
	DD	01e83eH
	DD	02d838H
	DD	03c830H
	DD	04b82bH
	DD	05a826H
	DD	069821H
	DD	07881cH
	DD	087817H
	DD	096813H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z DD 0174301H
	DD	0f843H
	DD	01e83eH
	DD	02d838H
	DD	03c830H
	DD	04b82bH
	DD	05a826H
	DD	069821H
	DD	07881cH
	DD	087817H
	DD	096813H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z DD 0174301H
	DD	0f843H
	DD	01e83eH
	DD	02d838H
	DD	03c830H
	DD	04b82bH
	DD	05a826H
	DD	069821H
	DD	07881cH
	DD	087817H
	DD	096813H
	DD	014010bH
	DD	03004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z DD 0174301H
	DD	0f843H
	DD	01e83eH
	DD	02d838H
	DD	03c830H
	DD	04b82bH
	DD	05a826H
	DD	069821H
	DD	07881cH
	DD	087817H
	DD	096813H
	DD	014010bH
	DD	03004H
	ORG $+24
?flt_plus_inf$initializer$@@3P6AXXZEA DQ FLAT:??__Eflt_plus_inf@@YAXXZ ; flt_plus_inf$initializer$
?ps_cst_plus_inf$initializer$@@3P6AXXZEA DQ FLAT:??__Eps_cst_plus_inf@@YAXXZ ; ps_cst_plus_inf$initializer$
?ps_cst_minus_inf$initializer$@@3P6AXXZEA DQ FLAT:??__Eps_cst_minus_inf@@YAXXZ ; ps_cst_minus_inf$initializer$
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ??__Eflt_plus_inf@@YAXXZ
text$di	SEGMENT
??__Eflt_plus_inf@@YAXXZ PROC				; `dynamic initializer for 'flt_plus_inf'', COMDAT

; 123  : static const float flt_plus_inf = -logf(0);	// let's keep C and C++ compilers happy.

	sub	rsp, 40					; 00000028H
	xorps	xmm0, xmm0
	call	logf
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	movss	DWORD PTR ?flt_plus_inf@@3MB, xmm0
	add	rsp, 40					; 00000028H
	ret	0
??__Eflt_plus_inf@@YAXXZ ENDP				; `dynamic initializer for 'flt_plus_inf''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ??__Eps_cst_plus_inf@@YAXXZ
text$di	SEGMENT
??__Eps_cst_plus_inf@@YAXXZ PROC			; `dynamic initializer for 'ps_cst_plus_inf'', COMDAT

; 125  : 	ps_cst_plus_inf	[4]	=	{  flt_plus_inf,  flt_plus_inf,  flt_plus_inf,  flt_plus_inf },

	movss	xmm0, DWORD PTR ?flt_plus_inf@@3MB
	shufps	xmm0, xmm0, 0
	movaps	XMMWORD PTR ?ps_cst_plus_inf@@3QBMB, xmm0
	ret	0
??__Eps_cst_plus_inf@@YAXXZ ENDP			; `dynamic initializer for 'ps_cst_plus_inf''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ??__Eps_cst_minus_inf@@YAXXZ
text$di	SEGMENT
??__Eps_cst_minus_inf@@YAXXZ PROC			; `dynamic initializer for 'ps_cst_minus_inf'', COMDAT

; 126  : 	ps_cst_minus_inf[4]	=	{ -flt_plus_inf, -flt_plus_inf, -flt_plus_inf, -flt_plus_inf };

	movss	xmm0, DWORD PTR ?flt_plus_inf@@3MB
	xorps	xmm0, DWORD PTR __xmm@80000000800000008000000080000000
	shufps	xmm0, xmm0, 0
	movaps	XMMWORD PTR ?ps_cst_minus_inf@@3QBMB, xmm0
	ret	0
??__Eps_cst_minus_inf@@YAXXZ ENDP			; `dynamic initializer for 'ps_cst_minus_inf''
text$di	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z
_TEXT	SEGMENT
RC$1 = 32
RC$2 = 32
RC$3 = 32
RC$4 = 32
RC$5 = 32
RC$6 = 32
RC$7 = 32
RC$8 = 32
RC$9 = 32
this$ = 288
m_def$ = 296
r_start$ = 304
r_dir$ = 312
r_range$ = 320
?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z PROC ; CDB::COLLIDER::ray_query, COMDAT

; 359  : {

$LN1550:
	mov	rax, rsp
	push	rbp
	push	rsi
	push	rdi
	push	r15
	lea	rbp, QWORD PTR [rax-87]
	sub	rsp, 248				; 000000f8H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB.h

; 86   : 			if (S_READY!=status)

	cmp	DWORD PTR [rdx+16], 0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 359  : {

	mov	r15, r9
	movaps	XMMWORD PTR [rax-56], xmm6
	mov	rsi, rcx
	movss	xmm6, DWORD PTR r_range$[rbp-193]
	movaps	XMMWORD PTR [rax-72], xmm7
	movaps	XMMWORD PTR [rax-88], xmm8
	mov	QWORD PTR [rax+16], r12
	mov	QWORD PTR [rax+24], r13
	mov	r13, r8
	mov	QWORD PTR [rax-40], r14
	mov	r14, rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB.h

; 86   : 			if (S_READY!=status)

	je	SHORT $LN34@ray_query

; 87   : 			{
; 88   : 				Log						("! WARNING: syncronized CDB::query");
; 89   : 				xrCriticalSection*	C	= (xrCriticalSection*) &cs;
; 90   : 				C->Enter				();

	mov	rcx, rdx
	call	QWORD PTR __imp_?Enter@xrCriticalSection@@QEAAXXZ

; 91   : 				C->Leave				();

	mov	rcx, r14
	call	QWORD PTR __imp_?Leave@xrCriticalSection@@QEAAXXZ
$LN34@ray_query:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 364  : 	const AABBNoLeafNode* N = T->GetNodes();

	mov	rax, QWORD PTR [r14+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1361 :         const pointer _Firstptr = _First._Ptr;

	mov	r12, QWORD PTR [rsi+16]

; 1362 :         const pointer _Lastptr  = _Last._Ptr;

	mov	rdx, QWORD PTR [rsi+24]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 364  : 	const AABBNoLeafNode* N = T->GetNodes();

	mov	rcx, QWORD PTR [rax+8]
	mov	rdi, QWORD PTR [rcx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1372 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

	cmp	r12, rdx
	je	SHORT $LN53@ray_query
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\xutility

; 3753 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	QWORD PTR [rsp+288], rbx

; 3754 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r12
	mov	rbx, rdx
	sub	rbx, rdx
	mov	r8, rbx
	call	memmove

; 3755 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+r12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1377 :             _Mylast = _Newlast;

	mov	rbx, QWORD PTR [rsp+288]
	mov	QWORD PTR [rsi+24], rax
$LN53@ray_query:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 367  : 	if (CPU::ID.feature&_CPU_FEATURE_SSE)	{

	mov	r8d, DWORD PTR [rsi]
	movaps	xmm3, xmm6
	mov	rcx, QWORD PTR [r14+24]
	mov	r10d, r8d
	mov	rdx, QWORD PTR [r14+40]
	mov	r9d, r8d
	movss	xmm5, DWORD PTR [r13]
	and	r10d, 1
	movss	xmm7, DWORD PTR [r13+4]
	and	r9d, 2
	movss	xmm8, DWORD PTR [r13+8]
	and	r8d, 4
	mov	rax, QWORD PTR __imp_?ID@CPU@@3U_processor_info@@A
	movss	xmm0, DWORD PTR [r15]
	movss	xmm1, DWORD PTR [r15+4]
	movss	xmm2, DWORD PTR [r15+8]
	test	BYTE PTR [rax+68], 2
	movaps	XMMWORD PTR [rsp+176], xmm9
	movaps	XMMWORD PTR [rsp+160], xmm10
	mov	r14, QWORD PTR [rsp+240]
	mov	r13, QWORD PTR [rsp+304]
	mov	r12, QWORD PTR [rsp+296]
	mulss	xmm3, xmm6
	mov	QWORD PTR RC$9[rsp], rsi
	movss	DWORD PTR RC$9[rsp+32], xmm5
	movss	DWORD PTR RC$9[rbp-157], xmm7
	movss	DWORD PTR RC$9[rbp-109], xmm3
	movss	DWORD PTR RC$9[rbp-153], xmm8
	movss	DWORD PTR RC$9[rbp-129], xmm0
	movss	DWORD PTR RC$9[rbp-125], xmm1
	movss	DWORD PTR RC$9[rbp-121], xmm2
	movss	DWORD PTR RC$9[rbp-113], xmm6
	mov	QWORD PTR RC$9[rsp+8], rcx
	mov	QWORD PTR RC$9[rsp+16], rdx
	je	$LN2@ray_query

; 368  : 		// SSE
; 369  : 		// Binary dispatcher
; 370  : 		if (ray_mode&OPT_CULL)		{

	movss	xmm4, DWORD PTR __real@3f800000
	lea	rcx, QWORD PTR RC$9[rsp]
	movaps	xmm9, xmm4
	movaps	xmm10, xmm4
	mov	rdx, rdi
	divss	xmm9, xmm0
	divss	xmm10, xmm1
	movss	DWORD PTR RC$9[rbp-145], xmm9
	movss	DWORD PTR RC$9[rbp-141], xmm10
	divss	xmm4, xmm2
	movss	DWORD PTR RC$9[rbp-137], xmm4
	test	r10d, r10d
	je	SHORT $LN4@ray_query

; 371  : 			if (ray_mode&OPT_ONLYFIRST)		{

	test	r9d, r9d
	je	SHORT $LN6@ray_query

; 372  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	r8d, r8d
	je	SHORT $LN8@ray_query

; 373  : 					ray_collider<true,true,true,true>		RC;
; 374  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 375  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,1>::_stab

; 376  : 				} else {

	jmp	$LN31@ray_query
$LN8@ray_query:

; 377  : 					ray_collider<true,true,true,false>		RC;
; 378  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 379  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,0>::_stab

; 380  : 				}
; 381  : 			} else {

	jmp	$LN31@ray_query
$LN6@ray_query:

; 382  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	r8d, r8d
	je	SHORT $LN10@ray_query

; 383  : 					ray_collider<true,true,false,true>		RC;
; 384  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 385  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,1>::_stab

; 386  : 				} else {

	jmp	$LN31@ray_query
$LN10@ray_query:

; 387  : 					ray_collider<true,true,false,false>		RC;
; 388  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 389  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,0>::_stab

; 390  : 				}
; 391  : 			}
; 392  : 		} else {

	jmp	$LN31@ray_query
$LN4@ray_query:

; 393  : 			if (ray_mode&OPT_ONLYFIRST)		{

	test	r9d, r9d
	je	SHORT $LN12@ray_query

; 394  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	r8d, r8d
	je	SHORT $LN14@ray_query

; 395  : 					ray_collider<true,false,true,true>		RC;
; 396  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 397  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,1>::_stab

; 398  : 				} else {

	jmp	$LN31@ray_query
$LN14@ray_query:

; 399  : 					ray_collider<true,false,true,false>		RC;
; 400  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 401  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,0>::_stab

; 402  : 				}
; 403  : 			} else {

	jmp	$LN31@ray_query
$LN12@ray_query:

; 404  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	r8d, r8d
	je	SHORT $LN16@ray_query

; 405  : 					ray_collider<true,false,false,true>		RC;
; 406  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 407  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,1>::_stab

; 408  : 				} else {

	jmp	$LN31@ray_query
$LN16@ray_query:

; 409  : 					ray_collider<true,false,false,false>	RC;
; 410  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 411  : 					RC._stab(N);

	call	?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,0>::_stab

; 412  : 				}
; 413  : 			}
; 414  : 		}
; 415  : 	} else {

	jmp	$LN31@ray_query
$LN2@ray_query:

; 416  : 		// FPU
; 417  : 		// Binary dispatcher
; 418  : 		if (ray_mode&OPT_CULL)		{

	movss	xmm9, DWORD PTR __real@3f800000
	movaps	xmm10, xmm0
	movss	xmm4, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
	movss	xmm5, DWORD PTR __real@34000000
	andps	xmm10, xmm4
	movaps	XMMWORD PTR [rsp+144], xmm11
	movaps	xmm11, xmm9
	movaps	XMMWORD PTR [rsp+128], xmm12
	movaps	xmm12, xmm9
	divss	xmm11, xmm0
	divss	xmm12, xmm1
	movss	DWORD PTR RC$8[rbp-145], xmm11
	movss	DWORD PTR RC$8[rbp-141], xmm12
	divss	xmm9, xmm2
	movss	DWORD PTR RC$8[rbp-137], xmm9
	test	r10d, r10d
	je	$LN18@ray_query

; 419  : 			if (ray_mode&OPT_ONLYFIRST)		{

	test	r9d, r9d
	je	SHORT $LN20@ray_query

; 420  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	r8d, r8d
	je	SHORT $LN22@ray_query

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm10, xmm5
	ja	SHORT $LN1270@ray_query
	mov	DWORD PTR RC$8[rbp-145], 0
$LN1270@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm1, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm1, xmm5
	ja	SHORT $LN1272@ray_query
	mov	DWORD PTR RC$8[rbp-141], 0
$LN1272@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm2, xmm5
	ja	SHORT $LN1274@ray_query
	mov	DWORD PTR RC$8[rbp-137], 0
$LN1274@ray_query:

; 421  : 					ray_collider<false,true,true,true>		RC;
; 422  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 423  : 					RC._stab(N);

	mov	rdx, rdi
	lea	rcx, QWORD PTR RC$8[rsp]
	call	?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,1>::_stab

; 424  : 				} else {

	jmp	$LN1548@ray_query
$LN22@ray_query:

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm10, xmm5
	ja	SHORT $LN1305@ray_query
	mov	DWORD PTR RC$7[rbp-145], 0
$LN1305@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm1, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm1, xmm5
	ja	SHORT $LN1307@ray_query
	mov	DWORD PTR RC$7[rbp-141], 0
$LN1307@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm2, xmm5
	ja	SHORT $LN1309@ray_query
	mov	DWORD PTR RC$7[rbp-137], 0
$LN1309@ray_query:

; 425  : 					ray_collider<false,true,true,false>		RC;
; 426  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 427  : 					RC._stab(N);

	mov	rdx, rdi
	lea	rcx, QWORD PTR RC$7[rsp]
	call	?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,0>::_stab

; 428  : 				}
; 429  : 			} else {

	jmp	$LN1548@ray_query
$LN20@ray_query:

; 430  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	r8d, r8d
	je	SHORT $LN24@ray_query

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm10, xmm5
	ja	SHORT $LN1340@ray_query
	mov	DWORD PTR RC$6[rbp-145], 0
$LN1340@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm1, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm1, xmm5
	ja	SHORT $LN1342@ray_query
	mov	DWORD PTR RC$6[rbp-141], 0
$LN1342@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm2, xmm5
	ja	SHORT $LN1344@ray_query
	mov	DWORD PTR RC$6[rbp-137], 0
$LN1344@ray_query:

; 431  : 					ray_collider<false,true,false,true>		RC;
; 432  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 433  : 					RC._stab(N);

	mov	rdx, rdi
	lea	rcx, QWORD PTR RC$6[rsp]
	call	?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,1>::_stab

; 434  : 				} else {

	jmp	$LN1548@ray_query
$LN24@ray_query:

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm10, xmm5
	ja	SHORT $LN1375@ray_query
	mov	DWORD PTR RC$5[rbp-145], 0
$LN1375@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm1, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm1, xmm5
	ja	SHORT $LN1377@ray_query
	mov	DWORD PTR RC$5[rbp-141], 0
$LN1377@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm2, xmm5
	ja	SHORT $LN1379@ray_query
	mov	DWORD PTR RC$5[rbp-137], 0
$LN1379@ray_query:

; 435  : 					ray_collider<false,true,false,false>	RC;
; 436  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 437  : 					RC._stab(N);

	mov	rdx, rdi
	lea	rcx, QWORD PTR RC$5[rsp]
	call	?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,0>::_stab

; 438  : 				}
; 439  : 			}
; 440  : 		} else {

	jmp	$LN1548@ray_query
$LN18@ray_query:

; 441  : 			if (ray_mode&OPT_ONLYFIRST)		{

	test	r9d, r9d
	je	SHORT $LN26@ray_query

; 442  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	r8d, r8d
	je	SHORT $LN28@ray_query

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm10, xmm5
	ja	SHORT $LN1410@ray_query
	mov	DWORD PTR RC$4[rbp-145], 0
$LN1410@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm1, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm1, xmm5
	ja	SHORT $LN1412@ray_query
	mov	DWORD PTR RC$4[rbp-141], 0
$LN1412@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm2, xmm5
	ja	SHORT $LN1414@ray_query
	mov	DWORD PTR RC$4[rbp-137], 0
$LN1414@ray_query:

; 443  : 					ray_collider<false,false,true,true>		RC;
; 444  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 445  : 					RC._stab(N);

	mov	rdx, rdi
	lea	rcx, QWORD PTR RC$4[rsp]
	call	?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,1>::_stab

; 446  : 				} else {

	jmp	$LN1548@ray_query
$LN28@ray_query:

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm10, xmm5
	ja	SHORT $LN1445@ray_query
	mov	DWORD PTR RC$3[rbp-145], 0
$LN1445@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm1, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm1, xmm5
	ja	SHORT $LN1447@ray_query
	mov	DWORD PTR RC$3[rbp-141], 0
$LN1447@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm2, xmm5
	ja	SHORT $LN1449@ray_query
	mov	DWORD PTR RC$3[rbp-137], 0
$LN1449@ray_query:

; 447  : 					ray_collider<false,false,true,false>	RC;
; 448  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 449  : 					RC._stab(N);

	mov	rdx, rdi
	lea	rcx, QWORD PTR RC$3[rsp]
	call	?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,0>::_stab

; 450  : 				}
; 451  : 			} else {

	jmp	SHORT $LN1548@ray_query
$LN26@ray_query:

; 452  : 				if (ray_mode&OPT_ONLYNEAREST)		{

	test	r8d, r8d
	je	SHORT $LN30@ray_query

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm10, xmm5
	ja	SHORT $LN1480@ray_query
	mov	DWORD PTR RC$2[rbp-145], 0
$LN1480@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm1, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm1, xmm5
	ja	SHORT $LN1482@ray_query
	mov	DWORD PTR RC$2[rbp-141], 0
$LN1482@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm2, xmm5
	ja	SHORT $LN1484@ray_query
	mov	DWORD PTR RC$2[rbp-137], 0
$LN1484@ray_query:

; 453  : 					ray_collider<false,false,false,true>	RC;
; 454  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 455  : 					RC._stab(N);

	mov	rdx, rdi
	lea	rcx, QWORD PTR RC$2[rsp]
	call	?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,1>::_stab

; 456  : 				} else {

	jmp	SHORT $LN1548@ray_query
$LN30@ray_query:

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm10, xmm5
	ja	SHORT $LN1515@ray_query
	mov	DWORD PTR RC$1[rbp-145], 0
$LN1515@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm1, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm1, xmm5
	ja	SHORT $LN1517@ray_query
	mov	DWORD PTR RC$1[rbp-141], 0
$LN1517@ray_query:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	andps	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm2, xmm5
	ja	SHORT $LN1519@ray_query
	mov	DWORD PTR RC$1[rbp-137], 0
$LN1519@ray_query:

; 457  : 					ray_collider<false,false,false,false>	RC;
; 458  : 					RC._init(this,m_def->verts,m_def->tris,r_start,r_dir,r_range);
; 459  : 					RC._stab(N);

	mov	rdx, rdi
	lea	rcx, QWORD PTR RC$1[rsp]
	call	?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,0>::_stab
$LN1548@ray_query:
	movaps	xmm11, XMMWORD PTR [rsp+144]
	movaps	xmm12, XMMWORD PTR [rsp+128]
$LN31@ray_query:
	movaps	xmm10, XMMWORD PTR [rsp+160]

; 460  : 				}
; 461  : 			}
; 462  : 		}
; 463  : 	}
; 464  : }

	lea	r11, QWORD PTR [rsp+248]
	movaps	xmm6, XMMWORD PTR [r11-24]
	movaps	xmm7, XMMWORD PTR [r11-40]
	movaps	xmm8, XMMWORD PTR [r11-56]
	movaps	xmm9, XMMWORD PTR [rsp+176]
	mov	rsp, r11
	pop	r15
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
?ray_query@COLLIDER@CDB@@QEAAXPEBVMODEL@2@AEBU?$_vector3@M@@1M@Z ENDP ; CDB::COLLIDER::ray_query
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,0,0,0>::_stab, COMDAT

; 328  : 	{

$LN301:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	esi, 1
	movss	xmm6, DWORD PTR P$2[rsp+8]
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	movaps	XMMWORD PTR [rax-56], xmm8
	lea	ebp, QWORD PTR [rsi+1]
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	15
$LL284@stab:

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	prefetchnta BYTE PTR [rax]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm0, xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rdx+4]
	movaps	xmm14, xmm10
	movss	xmm5, DWORD PTR [rdx+8]
	movaps	xmm12, xmm9
	subss	xmm14, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm13, DWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm11, xmm5
	subss	xmm12, DWORD PTR [rdx+16]
	subss	xmm11, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm10, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm14, xmm13
	mov	eax, esi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm9, DWORD PTR [rdx+16]
	addss	xmm5, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm1, xmm15
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
	movaps	xmm2, xmm15
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm2

; 39   : 	if(ray.pos[0] < min[0]) {

	jbe	SHORT $LN25@stab

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm14

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN295@stab
$LN25@stab:
	comiss	xmm13, xmm10
	jbe	SHORT $LN29@stab

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm10

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm10
$LN295@stab:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, xmm13
	mulss	xmm2, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN29@stab:
	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm12, xmm4
	jbe	SHORT $LN30@stab

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm12

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm12

; 52   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN296@stab
$LN30@stab:
	comiss	xmm4, xmm9
	jbe	SHORT $LN34@stab

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm9

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm9
$LN296@stab:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN34@stab:
	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm11, xmm3
	jbe	SHORT $LN35@stab

; 58   : 		coord[2]	= min[2];
; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm11
	je	SHORT $LN40@stab
	movaps	xmm0, xmm11
$LN297@stab:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, xmm3
	mulss	xmm0, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN40@stab:
	xor	ecx, ecx
	comiss	xmm1, xmm2
	cmova	ecx, esi

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm0, DWORD PTR MaxT$1[rsp+rcx*4]
	cmova	ecx, ebp

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+rcx*4], 0
	jl	$LN12@stab

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN44@stab

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
	ja	$LN12@stab

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm2
$LN299@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3
	comiss	xmm11, xmm6
	ja	$LN12@stab
	comiss	xmm6, xmm5
	jmp	$LN298@stab
$LN35@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm5
	jbe	SHORT $LN39@stab

; 62   : 		coord[2]	= max[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm5
	je	SHORT $LN40@stab
	movaps	xmm0, xmm5

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN297@stab
$LN39@stab:
	test	eax, eax
	je	SHORT $LN40@stab

; 69   : 		coord		= ray.pos;

	movsd	xmm1, QWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+40]

; 70   : 		return		true;

	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	mov	DWORD PTR P$2[rsp+8], eax
	movaps	xmm7, xmm0
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movsd	QWORD PTR P$2[rsp], xmm1
	movss	xmm8, DWORD PTR P$2[rsp]
	jmp	SHORT $LN293@stab
$LN44@stab:

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN49@stab

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 93   : 		return true;

	jmp	$LN299@stab
$LN49@stab:

; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN12@stab

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm0
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	SHORT $LN12@stab

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	SHORT $LN12@stab
	comiss	xmm7, xmm9
$LN298@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	ja	SHORT $LN12@stab
$LN293@stab:
	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	subss	xmm2, xmm13
	movaps	xmm0, xmm6
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 342  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN12@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdx+24], sil
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
	mov	rdx, QWORD PTR [rdx+24]
	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z ; ray_collider<0,0,0,0>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,0>::_stab
$LN9@stab:

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	je	$LL284@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
	call	?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z ; ray_collider<0,0,0,0>::_prim
$LN12@stab:

; 354  : 		else					_stab	(node->GetNeg());
; 355  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,0,0,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,0,0,0>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rdx, QWORD PTR D$[rsp]

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [rcx+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [rcx+80], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN4@init
	mov	DWORD PTR [rcx+48], eax
$LN4@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN6@init
	mov	DWORD PTR [rcx+52], eax
$LN6@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN8@init
	mov	DWORD PTR [rcx+56], eax
$LN8@init:

; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,0,0,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,0,0,1>::_stab, COMDAT

; 328  : 	{

$LN301:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	esi, 1
	movss	xmm6, DWORD PTR P$2[rsp+8]
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	movaps	XMMWORD PTR [rax-56], xmm8
	lea	ebp, QWORD PTR [rsi+1]
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	15
$LL284@stab:

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	prefetchnta BYTE PTR [rax]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm0, xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rdx+4]
	movaps	xmm14, xmm10
	movss	xmm5, DWORD PTR [rdx+8]
	movaps	xmm12, xmm9
	subss	xmm14, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm13, DWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm11, xmm5
	subss	xmm12, DWORD PTR [rdx+16]
	subss	xmm11, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm10, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm14, xmm13
	mov	eax, esi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm9, DWORD PTR [rdx+16]
	addss	xmm5, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm1, xmm15
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
	movaps	xmm2, xmm15
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm2

; 39   : 	if(ray.pos[0] < min[0]) {

	jbe	SHORT $LN25@stab

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm14

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN295@stab
$LN25@stab:
	comiss	xmm13, xmm10
	jbe	SHORT $LN29@stab

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm10

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm10
$LN295@stab:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, xmm13
	mulss	xmm2, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN29@stab:
	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm12, xmm4
	jbe	SHORT $LN30@stab

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm12

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm12

; 52   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN296@stab
$LN30@stab:
	comiss	xmm4, xmm9
	jbe	SHORT $LN34@stab

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm9

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm9
$LN296@stab:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN34@stab:
	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm11, xmm3
	jbe	SHORT $LN35@stab

; 58   : 		coord[2]	= min[2];
; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm11
	je	SHORT $LN40@stab
	movaps	xmm0, xmm11
$LN297@stab:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, xmm3
	mulss	xmm0, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN40@stab:
	xor	ecx, ecx
	comiss	xmm1, xmm2
	cmova	ecx, esi

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm0, DWORD PTR MaxT$1[rsp+rcx*4]
	cmova	ecx, ebp

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+rcx*4], 0
	jl	$LN12@stab

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN44@stab

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
	ja	$LN12@stab

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm2
$LN299@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3
	comiss	xmm11, xmm6
	ja	$LN12@stab
	comiss	xmm6, xmm5
	jmp	$LN298@stab
$LN35@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm5
	jbe	SHORT $LN39@stab

; 62   : 		coord[2]	= max[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm5
	je	SHORT $LN40@stab
	movaps	xmm0, xmm5

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN297@stab
$LN39@stab:
	test	eax, eax
	je	SHORT $LN40@stab

; 69   : 		coord		= ray.pos;

	movsd	xmm1, QWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+40]

; 70   : 		return		true;

	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	mov	DWORD PTR P$2[rsp+8], eax
	movaps	xmm7, xmm0
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movsd	QWORD PTR P$2[rsp], xmm1
	movss	xmm8, DWORD PTR P$2[rsp]
	jmp	SHORT $LN293@stab
$LN44@stab:

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN49@stab

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 93   : 		return true;

	jmp	$LN299@stab
$LN49@stab:

; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN12@stab

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm0
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	SHORT $LN12@stab

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	SHORT $LN12@stab
	comiss	xmm7, xmm9
$LN298@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	ja	SHORT $LN12@stab
$LN293@stab:
	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	subss	xmm2, xmm13
	movaps	xmm0, xmm6
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 342  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN12@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdx+24], sil
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
	mov	rdx, QWORD PTR [rdx+24]
	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z ; ray_collider<0,0,0,1>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,0,1>::_stab
$LN9@stab:

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	je	$LL284@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
	call	?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z ; ray_collider<0,0,0,1>::_prim
$LN12@stab:

; 354  : 		else					_stab	(node->GetNeg());
; 355  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,0,0,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,0,0,1>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rdx, QWORD PTR D$[rsp]

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [rcx+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [rcx+80], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN4@init
	mov	DWORD PTR [rcx+48], eax
$LN4@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN6@init
	mov	DWORD PTR [rcx+52], eax
$LN6@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN8@init
	mov	DWORD PTR [rcx+56], eax
$LN8@init:

; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,0,0,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,0,1,0>::_stab, COMDAT

; 328  : 	{

$LN308:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	ebp, 1
	movss	xmm6, DWORD PTR P$2[rsp+8]
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-40], xmm7
	mov	rsi, 7905747460161236407		; 6db6db6db6db6db7H
	movss	xmm7, DWORD PTR P$2[rsp+4]
	movaps	XMMWORD PTR [rax-56], xmm8
	lea	r14d, QWORD PTR [rbp+1]
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	15
$LL290@stab:

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	prefetchnta BYTE PTR [rax]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm0, xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rdx+4]
	movaps	xmm14, xmm10
	movss	xmm5, DWORD PTR [rdx+8]
	movaps	xmm12, xmm9
	subss	xmm14, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm13, DWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm11, xmm5
	subss	xmm12, DWORD PTR [rdx+16]
	subss	xmm11, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm10, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm14, xmm13
	mov	eax, ebp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm9, DWORD PTR [rdx+16]
	addss	xmm5, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm1, xmm15
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
	movaps	xmm2, xmm15
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm2

; 39   : 	if(ray.pos[0] < min[0]) {

	jbe	SHORT $LN25@stab

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm14

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN302@stab
$LN25@stab:
	comiss	xmm13, xmm10
	jbe	SHORT $LN29@stab

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm10

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm10
$LN302@stab:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, xmm13
	mulss	xmm2, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN29@stab:
	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm12, xmm4
	jbe	SHORT $LN30@stab

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm12

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm12

; 52   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN303@stab
$LN30@stab:
	comiss	xmm4, xmm9
	jbe	SHORT $LN34@stab

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm9

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm9
$LN303@stab:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN34@stab:
	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm11, xmm3
	jbe	SHORT $LN35@stab

; 58   : 		coord[2]	= min[2];
; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm11
	je	SHORT $LN40@stab
	movaps	xmm0, xmm11
$LN304@stab:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, xmm3
	mulss	xmm0, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN40@stab:
	xor	ecx, ecx
	comiss	xmm1, xmm2
	cmova	ecx, ebp

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm0, DWORD PTR MaxT$1[rsp+rcx*4]
	cmova	ecx, r14d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+rcx*4], 0
	jl	$LN12@stab

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN44@stab

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
	ja	$LN12@stab

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm2
$LN306@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3
	comiss	xmm11, xmm6
	ja	$LN12@stab
	comiss	xmm6, xmm5
	jmp	$LN305@stab
$LN35@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm5
	jbe	SHORT $LN39@stab

; 62   : 		coord[2]	= max[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm5
	je	SHORT $LN40@stab
	movaps	xmm0, xmm5

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN304@stab
$LN39@stab:
	test	eax, eax
	je	SHORT $LN40@stab

; 69   : 		coord		= ray.pos;

	movsd	xmm1, QWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+40]

; 70   : 		return		true;

	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	mov	DWORD PTR P$2[rsp+8], eax
	movaps	xmm7, xmm0
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movsd	QWORD PTR P$2[rsp], xmm1
	movss	xmm8, DWORD PTR P$2[rsp]
	jmp	SHORT $LN300@stab
$LN44@stab:

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, ebp
	jne	SHORT $LN49@stab

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 93   : 		return true;

	jmp	$LN306@stab
$LN49@stab:

; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, r14d
	jne	$LN12@stab

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm0
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
$LN305@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	ja	SHORT $LN12@stab
$LN300@stab:
	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	subss	xmm2, xmm13
	movaps	xmm0, xmm6
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 342  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN12@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdx+24], bpl
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
	mov	rdx, QWORD PTR [rdx+24]
	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z ; ray_collider<0,0,1,0>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,0>::_stab
$LN9@stab:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 3
	imul	rcx, rsi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 350  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	SHORT $LN12@stab

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, bpl
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	je	$LL290@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
	call	?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z ; ray_collider<0,0,1,0>::_prim
$LN12@stab:

; 354  : 		else					_stab	(node->GetNeg());
; 355  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	mov	rsp, r11
	pop	r14
	ret	0
?_stab@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,0,1,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,0,1,0>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rdx, QWORD PTR D$[rsp]

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [rcx+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [rcx+80], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN4@init
	mov	DWORD PTR [rcx+48], eax
$LN4@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN6@init
	mov	DWORD PTR [rcx+52], eax
$LN6@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN8@init
	mov	DWORD PTR [rcx+56], eax
$LN8@init:

; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,0,1,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,0,1,1>::_stab, COMDAT

; 328  : 	{

$LN308:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	ebp, 1
	movss	xmm6, DWORD PTR P$2[rsp+8]
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-40], xmm7
	mov	rsi, 7905747460161236407		; 6db6db6db6db6db7H
	movss	xmm7, DWORD PTR P$2[rsp+4]
	movaps	XMMWORD PTR [rax-56], xmm8
	lea	r14d, QWORD PTR [rbp+1]
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	15
$LL290@stab:

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	prefetchnta BYTE PTR [rax]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm0, xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rdx+4]
	movaps	xmm14, xmm10
	movss	xmm5, DWORD PTR [rdx+8]
	movaps	xmm12, xmm9
	subss	xmm14, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm13, DWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm11, xmm5
	subss	xmm12, DWORD PTR [rdx+16]
	subss	xmm11, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm10, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm14, xmm13
	mov	eax, ebp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm9, DWORD PTR [rdx+16]
	addss	xmm5, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm1, xmm15
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
	movaps	xmm2, xmm15
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm2

; 39   : 	if(ray.pos[0] < min[0]) {

	jbe	SHORT $LN25@stab

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm14

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN302@stab
$LN25@stab:
	comiss	xmm13, xmm10
	jbe	SHORT $LN29@stab

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm10

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm10
$LN302@stab:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, xmm13
	mulss	xmm2, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN29@stab:
	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm12, xmm4
	jbe	SHORT $LN30@stab

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm12

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm12

; 52   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN303@stab
$LN30@stab:
	comiss	xmm4, xmm9
	jbe	SHORT $LN34@stab

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm9

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm9
$LN303@stab:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN34@stab:
	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm11, xmm3
	jbe	SHORT $LN35@stab

; 58   : 		coord[2]	= min[2];
; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm11
	je	SHORT $LN40@stab
	movaps	xmm0, xmm11
$LN304@stab:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, xmm3
	mulss	xmm0, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN40@stab:
	xor	ecx, ecx
	comiss	xmm1, xmm2
	cmova	ecx, ebp

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm0, DWORD PTR MaxT$1[rsp+rcx*4]
	cmova	ecx, r14d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+rcx*4], 0
	jl	$LN12@stab

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN44@stab

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
	ja	$LN12@stab

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm2
$LN306@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3
	comiss	xmm11, xmm6
	ja	$LN12@stab
	comiss	xmm6, xmm5
	jmp	$LN305@stab
$LN35@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm5
	jbe	SHORT $LN39@stab

; 62   : 		coord[2]	= max[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm5
	je	SHORT $LN40@stab
	movaps	xmm0, xmm5

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN304@stab
$LN39@stab:
	test	eax, eax
	je	SHORT $LN40@stab

; 69   : 		coord		= ray.pos;

	movsd	xmm1, QWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+40]

; 70   : 		return		true;

	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	mov	DWORD PTR P$2[rsp+8], eax
	movaps	xmm7, xmm0
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movsd	QWORD PTR P$2[rsp], xmm1
	movss	xmm8, DWORD PTR P$2[rsp]
	jmp	SHORT $LN300@stab
$LN44@stab:

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, ebp
	jne	SHORT $LN49@stab

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 93   : 		return true;

	jmp	$LN306@stab
$LN49@stab:

; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, r14d
	jne	$LN12@stab

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm0
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
$LN305@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	ja	SHORT $LN12@stab
$LN300@stab:
	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	subss	xmm2, xmm13
	movaps	xmm0, xmm6
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 342  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN12@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdx+24], bpl
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
	mov	rdx, QWORD PTR [rdx+24]
	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z ; ray_collider<0,0,1,1>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,0,1,1>::_stab
$LN9@stab:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 3
	imul	rcx, rsi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 350  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	SHORT $LN12@stab

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, bpl
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	je	$LL290@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
	call	?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z ; ray_collider<0,0,1,1>::_prim
$LN12@stab:

; 354  : 		else					_stab	(node->GetNeg());
; 355  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	mov	rsp, r11
	pop	r14
	ret	0
?_stab@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,0,1,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,0,1,1>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rdx, QWORD PTR D$[rsp]

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [rcx+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [rcx+80], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN4@init
	mov	DWORD PTR [rcx+48], eax
$LN4@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN6@init
	mov	DWORD PTR [rcx+52], eax
$LN6@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN8@init
	mov	DWORD PTR [rcx+56], eax
$LN8@init:

; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$0A@$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,0,1,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,1,0,0>::_stab, COMDAT

; 328  : 	{

$LN301:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	esi, 1
	movss	xmm6, DWORD PTR P$2[rsp+8]
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	movaps	XMMWORD PTR [rax-56], xmm8
	lea	ebp, QWORD PTR [rsi+1]
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	15
$LL284@stab:

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	prefetchnta BYTE PTR [rax]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm0, xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rdx+4]
	movaps	xmm14, xmm10
	movss	xmm5, DWORD PTR [rdx+8]
	movaps	xmm12, xmm9
	subss	xmm14, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm13, DWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm11, xmm5
	subss	xmm12, DWORD PTR [rdx+16]
	subss	xmm11, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm10, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm14, xmm13
	mov	eax, esi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm9, DWORD PTR [rdx+16]
	addss	xmm5, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm1, xmm15
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
	movaps	xmm2, xmm15
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm2

; 39   : 	if(ray.pos[0] < min[0]) {

	jbe	SHORT $LN25@stab

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm14

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN295@stab
$LN25@stab:
	comiss	xmm13, xmm10
	jbe	SHORT $LN29@stab

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm10

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm10
$LN295@stab:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, xmm13
	mulss	xmm2, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN29@stab:
	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm12, xmm4
	jbe	SHORT $LN30@stab

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm12

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm12

; 52   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN296@stab
$LN30@stab:
	comiss	xmm4, xmm9
	jbe	SHORT $LN34@stab

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm9

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm9
$LN296@stab:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN34@stab:
	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm11, xmm3
	jbe	SHORT $LN35@stab

; 58   : 		coord[2]	= min[2];
; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm11
	je	SHORT $LN40@stab
	movaps	xmm0, xmm11
$LN297@stab:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, xmm3
	mulss	xmm0, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN40@stab:
	xor	ecx, ecx
	comiss	xmm1, xmm2
	cmova	ecx, esi

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm0, DWORD PTR MaxT$1[rsp+rcx*4]
	cmova	ecx, ebp

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+rcx*4], 0
	jl	$LN12@stab

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN44@stab

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
	ja	$LN12@stab

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm2
$LN299@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3
	comiss	xmm11, xmm6
	ja	$LN12@stab
	comiss	xmm6, xmm5
	jmp	$LN298@stab
$LN35@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm5
	jbe	SHORT $LN39@stab

; 62   : 		coord[2]	= max[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm5
	je	SHORT $LN40@stab
	movaps	xmm0, xmm5

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN297@stab
$LN39@stab:
	test	eax, eax
	je	SHORT $LN40@stab

; 69   : 		coord		= ray.pos;

	movsd	xmm1, QWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+40]

; 70   : 		return		true;

	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	mov	DWORD PTR P$2[rsp+8], eax
	movaps	xmm7, xmm0
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movsd	QWORD PTR P$2[rsp], xmm1
	movss	xmm8, DWORD PTR P$2[rsp]
	jmp	SHORT $LN293@stab
$LN44@stab:

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN49@stab

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 93   : 		return true;

	jmp	$LN299@stab
$LN49@stab:

; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN12@stab

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm0
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	SHORT $LN12@stab

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	SHORT $LN12@stab
	comiss	xmm7, xmm9
$LN298@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	ja	SHORT $LN12@stab
$LN293@stab:
	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	subss	xmm2, xmm13
	movaps	xmm0, xmm6
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 342  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN12@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdx+24], sil
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
	mov	rdx, QWORD PTR [rdx+24]
	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z ; ray_collider<0,1,0,0>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,0>::_stab
$LN9@stab:

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	je	$LL284@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
	call	?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z ; ray_collider<0,1,0,0>::_prim
$LN12@stab:

; 354  : 		else					_stab	(node->GetNeg());
; 355  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,1,0,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,1,0,0>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rdx, QWORD PTR D$[rsp]

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [rcx+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [rcx+80], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN4@init
	mov	DWORD PTR [rcx+48], eax
$LN4@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN6@init
	mov	DWORD PTR [rcx+52], eax
$LN6@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN8@init
	mov	DWORD PTR [rcx+56], eax
$LN8@init:

; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,1,0,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,1,0,1>::_stab, COMDAT

; 328  : 	{

$LN301:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	push	rdi
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	esi, 1
	movss	xmm6, DWORD PTR P$2[rsp+8]
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-40], xmm7
	movss	xmm7, DWORD PTR P$2[rsp+4]
	movaps	XMMWORD PTR [rax-56], xmm8
	lea	ebp, QWORD PTR [rsi+1]
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	15
$LL284@stab:

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	prefetchnta BYTE PTR [rax]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm0, xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rdx+4]
	movaps	xmm14, xmm10
	movss	xmm5, DWORD PTR [rdx+8]
	movaps	xmm12, xmm9
	subss	xmm14, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm13, DWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm11, xmm5
	subss	xmm12, DWORD PTR [rdx+16]
	subss	xmm11, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm10, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm14, xmm13
	mov	eax, esi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm9, DWORD PTR [rdx+16]
	addss	xmm5, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm1, xmm15
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
	movaps	xmm2, xmm15
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm2

; 39   : 	if(ray.pos[0] < min[0]) {

	jbe	SHORT $LN25@stab

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm14

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN295@stab
$LN25@stab:
	comiss	xmm13, xmm10
	jbe	SHORT $LN29@stab

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm10

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm10
$LN295@stab:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, xmm13
	mulss	xmm2, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN29@stab:
	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm12, xmm4
	jbe	SHORT $LN30@stab

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm12

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm12

; 52   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN296@stab
$LN30@stab:
	comiss	xmm4, xmm9
	jbe	SHORT $LN34@stab

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm9

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm9
$LN296@stab:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN34@stab:
	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm11, xmm3
	jbe	SHORT $LN35@stab

; 58   : 		coord[2]	= min[2];
; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm11
	je	SHORT $LN40@stab
	movaps	xmm0, xmm11
$LN297@stab:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, xmm3
	mulss	xmm0, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN40@stab:
	xor	ecx, ecx
	comiss	xmm1, xmm2
	cmova	ecx, esi

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm0, DWORD PTR MaxT$1[rsp+rcx*4]
	cmova	ecx, ebp

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+rcx*4], 0
	jl	$LN12@stab

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN44@stab

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
	ja	$LN12@stab

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm2
$LN299@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3
	comiss	xmm11, xmm6
	ja	$LN12@stab
	comiss	xmm6, xmm5
	jmp	$LN298@stab
$LN35@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm5
	jbe	SHORT $LN39@stab

; 62   : 		coord[2]	= max[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm5
	je	SHORT $LN40@stab
	movaps	xmm0, xmm5

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN297@stab
$LN39@stab:
	test	eax, eax
	je	SHORT $LN40@stab

; 69   : 		coord		= ray.pos;

	movsd	xmm1, QWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+40]

; 70   : 		return		true;

	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	mov	DWORD PTR P$2[rsp+8], eax
	movaps	xmm7, xmm0
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movsd	QWORD PTR P$2[rsp], xmm1
	movss	xmm8, DWORD PTR P$2[rsp]
	jmp	SHORT $LN293@stab
$LN44@stab:

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, esi
	jne	SHORT $LN49@stab

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 93   : 		return true;

	jmp	$LN299@stab
$LN49@stab:

; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, ebp
	jne	$LN12@stab

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm0
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	SHORT $LN12@stab

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	SHORT $LN12@stab
	comiss	xmm7, xmm9
$LN298@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	ja	SHORT $LN12@stab
$LN293@stab:
	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	subss	xmm2, xmm13
	movaps	xmm0, xmm6
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 342  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN12@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdx+24], sil
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
	mov	rdx, QWORD PTR [rdx+24]
	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z ; ray_collider<0,1,0,1>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,0,1>::_stab
$LN9@stab:

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, sil
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	je	$LL284@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
	call	?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z ; ray_collider<0,1,0,1>::_prim
$LN12@stab:

; 354  : 		else					_stab	(node->GetNeg());
; 355  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	mov	rsp, r11
	pop	rdi
	ret	0
?_stab@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,1,0,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,1,0,1>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rdx, QWORD PTR D$[rsp]

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [rcx+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [rcx+80], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN4@init
	mov	DWORD PTR [rcx+48], eax
$LN4@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN6@init
	mov	DWORD PTR [rcx+52], eax
$LN6@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN8@init
	mov	DWORD PTR [rcx+56], eax
$LN8@init:

; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$0A@$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,1,0,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,1,1,0>::_stab, COMDAT

; 328  : 	{

$LN308:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	ebp, 1
	movss	xmm6, DWORD PTR P$2[rsp+8]
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-40], xmm7
	mov	rsi, 7905747460161236407		; 6db6db6db6db6db7H
	movss	xmm7, DWORD PTR P$2[rsp+4]
	movaps	XMMWORD PTR [rax-56], xmm8
	lea	r14d, QWORD PTR [rbp+1]
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	15
$LL290@stab:

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	prefetchnta BYTE PTR [rax]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm0, xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rdx+4]
	movaps	xmm14, xmm10
	movss	xmm5, DWORD PTR [rdx+8]
	movaps	xmm12, xmm9
	subss	xmm14, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm13, DWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm11, xmm5
	subss	xmm12, DWORD PTR [rdx+16]
	subss	xmm11, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm10, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm14, xmm13
	mov	eax, ebp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm9, DWORD PTR [rdx+16]
	addss	xmm5, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm1, xmm15
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
	movaps	xmm2, xmm15
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm2

; 39   : 	if(ray.pos[0] < min[0]) {

	jbe	SHORT $LN25@stab

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm14

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN302@stab
$LN25@stab:
	comiss	xmm13, xmm10
	jbe	SHORT $LN29@stab

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm10

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm10
$LN302@stab:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, xmm13
	mulss	xmm2, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN29@stab:
	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm12, xmm4
	jbe	SHORT $LN30@stab

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm12

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm12

; 52   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN303@stab
$LN30@stab:
	comiss	xmm4, xmm9
	jbe	SHORT $LN34@stab

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm9

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm9
$LN303@stab:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN34@stab:
	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm11, xmm3
	jbe	SHORT $LN35@stab

; 58   : 		coord[2]	= min[2];
; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm11
	je	SHORT $LN40@stab
	movaps	xmm0, xmm11
$LN304@stab:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, xmm3
	mulss	xmm0, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN40@stab:
	xor	ecx, ecx
	comiss	xmm1, xmm2
	cmova	ecx, ebp

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm0, DWORD PTR MaxT$1[rsp+rcx*4]
	cmova	ecx, r14d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+rcx*4], 0
	jl	$LN12@stab

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN44@stab

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
	ja	$LN12@stab

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm2
$LN306@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3
	comiss	xmm11, xmm6
	ja	$LN12@stab
	comiss	xmm6, xmm5
	jmp	$LN305@stab
$LN35@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm5
	jbe	SHORT $LN39@stab

; 62   : 		coord[2]	= max[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm5
	je	SHORT $LN40@stab
	movaps	xmm0, xmm5

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN304@stab
$LN39@stab:
	test	eax, eax
	je	SHORT $LN40@stab

; 69   : 		coord		= ray.pos;

	movsd	xmm1, QWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+40]

; 70   : 		return		true;

	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	mov	DWORD PTR P$2[rsp+8], eax
	movaps	xmm7, xmm0
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movsd	QWORD PTR P$2[rsp], xmm1
	movss	xmm8, DWORD PTR P$2[rsp]
	jmp	SHORT $LN300@stab
$LN44@stab:

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, ebp
	jne	SHORT $LN49@stab

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 93   : 		return true;

	jmp	$LN306@stab
$LN49@stab:

; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, r14d
	jne	$LN12@stab

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm0
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
$LN305@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	ja	SHORT $LN12@stab
$LN300@stab:
	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	subss	xmm2, xmm13
	movaps	xmm0, xmm6
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 342  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN12@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdx+24], bpl
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
	mov	rdx, QWORD PTR [rdx+24]
	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z ; ray_collider<0,1,1,0>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,0>::_stab
$LN9@stab:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 3
	imul	rcx, rsi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 350  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	SHORT $LN12@stab

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, bpl
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	je	$LL290@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
	call	?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z ; ray_collider<0,1,1,0>::_prim
$LN12@stab:

; 354  : 		else					_stab	(node->GetNeg());
; 355  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	mov	rsp, r11
	pop	r14
	ret	0
?_stab@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,1,1,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,1,1,0>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rdx, QWORD PTR D$[rsp]

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [rcx+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [rcx+80], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN4@init
	mov	DWORD PTR [rcx+48], eax
$LN4@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN6@init
	mov	DWORD PTR [rcx+52], eax
$LN6@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN8@init
	mov	DWORD PTR [rcx+56], eax
$LN8@init:

; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$0A@$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,1,1,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
MaxT$1 = 32
P$2 = 48
this$ = 240
node$ = 248
?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<0,1,1,1>::_stab, COMDAT

; 328  : 	{

$LN308:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rbp
	mov	QWORD PTR [rax+24], rsi
	mov	QWORD PTR [rax+32], rdi
	push	r14
	sub	rsp, 224				; 000000e0H
	movaps	XMMWORD PTR [rax-24], xmm6
	mov	ebp, 1
	movss	xmm6, DWORD PTR P$2[rsp+8]
	mov	rbx, rcx
	movaps	XMMWORD PTR [rax-40], xmm7
	mov	rsi, 7905747460161236407		; 6db6db6db6db6db7H
	movss	xmm7, DWORD PTR P$2[rsp+4]
	movaps	XMMWORD PTR [rax-56], xmm8
	lea	r14d, QWORD PTR [rbp+1]
	movss	xmm8, DWORD PTR P$2[rsp]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+96], xmm13
	movaps	XMMWORD PTR [rsp+80], xmm14
	movaps	XMMWORD PTR [rsp+64], xmm15
	movss	xmm15, DWORD PTR __real@bf800000
	npad	15
$LL290@stab:

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	prefetchnta BYTE PTR [rax]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rdx]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm0, xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rdx+4]
	movaps	xmm14, xmm10
	movss	xmm5, DWORD PTR [rdx+8]
	movaps	xmm12, xmm9
	subss	xmm14, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm13, DWORD PTR [rbx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm11, xmm5
	subss	xmm12, DWORD PTR [rdx+16]
	subss	xmm11, DWORD PTR [rdx+20]

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm10, DWORD PTR [rdx+12]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm14, xmm13
	mov	eax, ebp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm9, DWORD PTR [rdx+16]
	addss	xmm5, DWORD PTR [rdx+20]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movaps	xmm1, xmm15
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
	movaps	xmm2, xmm15
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
	movss	DWORD PTR MaxT$1[rsp], xmm2

; 39   : 	if(ray.pos[0] < min[0]) {

	jbe	SHORT $LN25@stab

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm14

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm14

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN302@stab
$LN25@stab:
	comiss	xmm13, xmm10
	jbe	SHORT $LN29@stab

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm8, xmm10

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+48], eax
	je	SHORT $LN29@stab
	movaps	xmm2, xmm10
$LN302@stab:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, xmm13
	mulss	xmm2, DWORD PTR [rbx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN29@stab:
	movss	xmm4, DWORD PTR [rbx+36]
	comiss	xmm12, xmm4
	jbe	SHORT $LN30@stab

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm12

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm12

; 52   : 	} else if(ray.pos[1] > max[1]) {

	jmp	SHORT $LN303@stab
$LN30@stab:
	comiss	xmm4, xmm9
	jbe	SHORT $LN34@stab

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movaps	xmm7, xmm9

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+52], eax
	je	SHORT $LN34@stab
	movaps	xmm1, xmm9
$LN303@stab:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rbx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN34@stab:
	movss	xmm3, DWORD PTR [rbx+40]
	comiss	xmm11, xmm3
	jbe	SHORT $LN35@stab

; 58   : 		coord[2]	= min[2];
; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm11
	je	SHORT $LN40@stab
	movaps	xmm0, xmm11
$LN304@stab:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, xmm3
	mulss	xmm0, DWORD PTR [rbx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN40@stab:
	xor	ecx, ecx
	comiss	xmm1, xmm2
	cmova	ecx, ebp

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	comiss	xmm0, DWORD PTR MaxT$1[rsp+rcx*4]
	cmova	ecx, r14d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+rcx*4], 0
	jl	$LN12@stab

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	ecx, ecx
	jne	$LN44@stab

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm7, xmm2
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
	ja	$LN12@stab

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	movaps	xmm6, xmm2
$LN306@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	mulss	xmm6, DWORD PTR [rbx+72]
	addss	xmm6, xmm3
	comiss	xmm11, xmm6
	ja	$LN12@stab
	comiss	xmm6, xmm5
	jmp	$LN305@stab
$LN35@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm3, xmm5
	jbe	SHORT $LN39@stab

; 62   : 		coord[2]	= max[2];
; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rbx+56], 0
	movaps	xmm6, xmm5
	je	SHORT $LN40@stab
	movaps	xmm0, xmm5

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN304@stab
$LN39@stab:
	test	eax, eax
	je	SHORT $LN40@stab

; 69   : 		coord		= ray.pos;

	movsd	xmm1, QWORD PTR [rbx+32]
	mov	eax, DWORD PTR [rbx+40]

; 70   : 		return		true;

	movaps	xmm0, xmm1
	shufps	xmm0, xmm0, 85				; 00000055H
	mov	DWORD PTR P$2[rsp+8], eax
	movaps	xmm7, xmm0
	movss	xmm6, DWORD PTR P$2[rsp+8]
	movsd	QWORD PTR P$2[rsp], xmm1
	movss	xmm8, DWORD PTR P$2[rsp]
	jmp	SHORT $LN300@stab
$LN44@stab:

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	ecx, ebp
	jne	SHORT $LN49@stab

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm8, xmm1
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	movaps	xmm6, xmm1

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;
; 93   : 		return true;

	jmp	$LN306@stab
$LN49@stab:

; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	ecx, r14d
	jne	$LN12@stab

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm8, xmm0
	mulss	xmm8, DWORD PTR [rbx+64]
	addss	xmm8, xmm13
	comiss	xmm14, xmm8

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	ja	$LN12@stab
	comiss	xmm8, xmm10
	ja	$LN12@stab

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	movaps	xmm7, xmm0
	mulss	xmm7, DWORD PTR [rbx+68]
	addss	xmm7, xmm4
	comiss	xmm12, xmm7

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	ja	$LN12@stab
	comiss	xmm7, xmm9
$LN305@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 301  :         return (x - v.x)*(x - v.x) + (y - v.y)*(y - v.y) + (z - v.z)*(z - v.z);

	ja	SHORT $LN12@stab
$LN300@stab:
	movaps	xmm1, xmm7
	movaps	xmm2, xmm8
	subss	xmm2, xmm13
	movaps	xmm0, xmm6
	subss	xmm1, xmm4
	subss	xmm0, xmm3
	mulss	xmm2, xmm2
	mulss	xmm1, xmm1
	mulss	xmm0, xmm0
	addss	xmm2, xmm1
	addss	xmm2, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 342  : 			if (P.distance_to_sqr(ray.pos)>rRange2)											return;

	comiss	xmm2, DWORD PTR [rbx+84]
	ja	SHORT $LN12@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdx+24], bpl
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rcx, rbx
	mov	rdx, QWORD PTR [rdx+24]
	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z ; ray_collider<0,1,1,1>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<0,1,1,1>::_stab
$LN9@stab:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 3
	imul	rcx, rsi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 350  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	SHORT $LN12@stab

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, bpl
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	je	$LL290@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
	call	?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z ; ray_collider<0,1,1,1>::_prim
$LN12@stab:

; 354  : 		else					_stab	(node->GetNeg());
; 355  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+80]
	lea	r11, QWORD PTR [rsp+224]
	mov	rbx, QWORD PTR [r11+16]
	mov	rbp, QWORD PTR [r11+24]
	mov	rsi, QWORD PTR [r11+32]
	mov	rdi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+64]
	mov	rsp, r11
	pop	r14
	ret	0
?_stab@?$ray_collider@$0A@$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<0,1,1,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$0A@$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$0A@$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<0,1,1,1>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm2, DWORD PTR __xmm@7fffffff7fffffff7fffffff7fffffff
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	movss	xmm3, DWORD PTR __real@34000000
	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rdx, QWORD PTR D$[rsp]

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	divss	xmm0, DWORD PTR [rdx]
	movss	DWORD PTR [rcx+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rdx+4]
	movss	DWORD PTR [rcx+52], xmm0
	divss	xmm1, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [rcx+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+64], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+68], eax
	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [rcx+80], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	xor	eax, eax
	mulss	xmm0, xmm0
	movss	DWORD PTR [rcx+84], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm1, DWORD PTR [rdx]
	andps	xmm1, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;

	comiss	xmm1, xmm3
	ja	SHORT $LN4@init
	mov	DWORD PTR [rcx+48], eax
$LN4@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+4]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN6@init
	mov	DWORD PTR [rcx+52], eax
$LN6@init:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.16299.0\ucrt\corecrt_math.h

; 671  :             return (float)fabs(_X);

	movss	xmm0, DWORD PTR [rdx+8]
	andps	xmm0, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;

	comiss	xmm0, xmm3
	ja	SHORT $LN8@init
	mov	DWORD PTR [rcx+56], eax
$LN8@init:

; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$0A@$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<0,1,1,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 64
node$ = 72
?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,0,0,0>::_stab, COMDAT

; 328  : 	{

$LN294:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	r8, rdx
	mov	rbx, rcx
	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]
	xorps	xmm6, xmm6

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [rdx+12]
	movss	xmm0, DWORD PTR [rdx+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [rdx+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm5, xmm2
	movlhps	xmm3, xmm0
	subps	xmm5, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm5, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm5, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm5
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm5, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm5, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm5

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm5, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm5, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm5
	movhlps	xmm0, xmm5

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm5, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6
	setae	al
	comiss	xmm2, xmm5
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN12@stab
$LL284@stab:

; 337  : 			if (d>rRange)																	return;

	comiss	xmm5, DWORD PTR [rbx+80]
	ja	$LN12@stab

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [r8+24]
	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z ; ray_collider<1,0,0,0>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,0>::_stab
$LN9@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN289@stab

; 354  : 		else					_stab	(node->GetNeg());

	mov	r8, QWORD PTR [rdi]
	mov	rax, QWORD PTR [r8+32]
	lea	rdi, QWORD PTR [r8+32]

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [r8]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8+12]
	movss	xmm0, DWORD PTR [r8+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rbx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rbx+32]
	mulps	xmm4, XMMWORD PTR [rbx+48]
	mulps	xmm3, XMMWORD PTR [rbx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movaps	xmm5, xmm4
	setae	al
	comiss	xmm2, xmm4
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL284@stab

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN289@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z ; ray_collider<1,0,0,0>::_prim
$LN12@stab:

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_stab@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,0,0,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,0,0,0>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 190  : 	{

	mov	r10, rcx

; 191  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [r10+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 198  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [r10+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 198  : 		rRange2			= R*R;

	movss	DWORD PTR [r10+84], xmm0

; 199  : 		if (!bUseSSE)	{
; 200  : 			// for FPU - zero out inf
; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,0,0,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 64
node$ = 72
?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,0,0,1>::_stab, COMDAT

; 328  : 	{

$LN294:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	r8, rdx
	mov	rbx, rcx
	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]
	xorps	xmm6, xmm6

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [rdx+12]
	movss	xmm0, DWORD PTR [rdx+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [rdx+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm5, xmm2
	movlhps	xmm3, xmm0
	subps	xmm5, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm5, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm5, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm5
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm5, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm5, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm5

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm5, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm5, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm5
	movhlps	xmm0, xmm5

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm5, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6
	setae	al
	comiss	xmm2, xmm5
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN12@stab
$LL284@stab:

; 337  : 			if (d>rRange)																	return;

	comiss	xmm5, DWORD PTR [rbx+80]
	ja	$LN12@stab

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [r8+24]
	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z ; ray_collider<1,0,0,1>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,0,1>::_stab
$LN9@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN289@stab

; 354  : 		else					_stab	(node->GetNeg());

	mov	r8, QWORD PTR [rdi]
	mov	rax, QWORD PTR [r8+32]
	lea	rdi, QWORD PTR [r8+32]

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [r8]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8+12]
	movss	xmm0, DWORD PTR [r8+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rbx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rbx+32]
	mulps	xmm4, XMMWORD PTR [rbx+48]
	mulps	xmm3, XMMWORD PTR [rbx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movaps	xmm5, xmm4
	setae	al
	comiss	xmm2, xmm4
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL284@stab

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN289@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z ; ray_collider<1,0,0,1>::_prim
$LN12@stab:

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_stab@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,0,0,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,0,0,1>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 190  : 	{

	mov	r10, rcx

; 191  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [r10+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 198  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [r10+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 198  : 		rRange2			= R*R;

	movss	DWORD PTR [r10+84], xmm0

; 199  : 		if (!bUseSSE)	{
; 200  : 			// for FPU - zero out inf
; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$00$0A@$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,0,0,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 64
node$ = 72
?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,0,1,0>::_stab, COMDAT

; 328  : 	{

$LN302:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	r8, rdx
	mov	rbx, rcx
	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]
	xorps	xmm6, xmm6

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [rdx+12]
	movss	xmm0, DWORD PTR [rdx+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [rdx+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm5, xmm2
	movlhps	xmm3, xmm0
	subps	xmm5, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm5, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm5, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm5
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm5, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm5, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm5

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm5, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm5, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm5
	movhlps	xmm0, xmm5

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm5, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6
	setae	al
	comiss	xmm2, xmm5
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN12@stab

; 231  :         return 		isect_sse	(box,ray,dist);

	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, 7905747460161236407		; 6db6db6db6db6db7H
$LL290@stab:

; 337  : 			if (d>rRange)																	return;

	comiss	xmm5, DWORD PTR [rbx+80]
	ja	$LN300@stab

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [r8+24]
	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z ; ray_collider<1,0,1,0>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,0>::_stab
$LN9@stab:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 3
	imul	rcx, rsi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 350  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	$LN300@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN296@stab

; 354  : 		else					_stab	(node->GetNeg());

	mov	r8, QWORD PTR [rdi]
	mov	rax, QWORD PTR [r8+32]
	lea	rdi, QWORD PTR [r8+32]

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [r8]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8+12]
	movss	xmm0, DWORD PTR [r8+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rbx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rbx+32]
	mulps	xmm4, XMMWORD PTR [rbx+48]
	mulps	xmm3, XMMWORD PTR [rbx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movaps	xmm5, xmm4
	setae	al
	comiss	xmm2, xmm4
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL290@stab
	jmp	SHORT $LN300@stab
$LN296@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z ; ray_collider<1,0,1,0>::_prim
$LN300@stab:
	mov	rsi, QWORD PTR [rsp+64]
$LN12@stab:

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_stab@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,0,1,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,0,1,0>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 190  : 	{

	mov	r10, rcx

; 191  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [r10+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 198  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [r10+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 198  : 		rRange2			= R*R;

	movss	DWORD PTR [r10+84], xmm0

; 199  : 		if (!bUseSSE)	{
; 200  : 			// for FPU - zero out inf
; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$00$0A@$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,0,1,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 64
node$ = 72
?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,0,1,1>::_stab, COMDAT

; 328  : 	{

$LN302:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	r8, rdx
	mov	rbx, rcx
	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]
	xorps	xmm6, xmm6

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [rdx+12]
	movss	xmm0, DWORD PTR [rdx+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [rdx+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm5, xmm2
	movlhps	xmm3, xmm0
	subps	xmm5, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm5, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm5, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm5
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm5, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm5, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm5

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm5, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm5, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm5
	movhlps	xmm0, xmm5

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm5, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6
	setae	al
	comiss	xmm2, xmm5
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN12@stab

; 231  :         return 		isect_sse	(box,ray,dist);

	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, 7905747460161236407		; 6db6db6db6db6db7H
$LL290@stab:

; 337  : 			if (d>rRange)																	return;

	comiss	xmm5, DWORD PTR [rbx+80]
	ja	$LN300@stab

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [r8+24]
	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z ; ray_collider<1,0,1,1>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,0,1,1>::_stab
$LN9@stab:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 3
	imul	rcx, rsi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 350  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	$LN300@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN296@stab

; 354  : 		else					_stab	(node->GetNeg());

	mov	r8, QWORD PTR [rdi]
	mov	rax, QWORD PTR [r8+32]
	lea	rdi, QWORD PTR [r8+32]

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [r8]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8+12]
	movss	xmm0, DWORD PTR [r8+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rbx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rbx+32]
	mulps	xmm4, XMMWORD PTR [rbx+48]
	mulps	xmm3, XMMWORD PTR [rbx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movaps	xmm5, xmm4
	setae	al
	comiss	xmm2, xmm4
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL290@stab
	jmp	SHORT $LN300@stab
$LN296@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z ; ray_collider<1,0,1,1>::_prim
$LN300@stab:
	mov	rsi, QWORD PTR [rsp+64]
$LN12@stab:

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_stab@?$ray_collider@$00$0A@$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,0,1,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,0,1,1>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 190  : 	{

	mov	r10, rcx

; 191  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [r10+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 198  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [r10+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 198  : 		rRange2			= R*R;

	movss	DWORD PTR [r10+84], xmm0

; 199  : 		if (!bUseSSE)	{
; 200  : 			// for FPU - zero out inf
; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$00$0A@$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,0,1,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 64
node$ = 72
?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,1,0,0>::_stab, COMDAT

; 328  : 	{

$LN294:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	r8, rdx
	mov	rbx, rcx
	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]
	xorps	xmm6, xmm6

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [rdx+12]
	movss	xmm0, DWORD PTR [rdx+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [rdx+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm5, xmm2
	movlhps	xmm3, xmm0
	subps	xmm5, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm5, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm5, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm5
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm5, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm5, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm5

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm5, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm5, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm5
	movhlps	xmm0, xmm5

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm5, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6
	setae	al
	comiss	xmm2, xmm5
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN12@stab
$LL284@stab:

; 337  : 			if (d>rRange)																	return;

	comiss	xmm5, DWORD PTR [rbx+80]
	ja	$LN12@stab

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [r8+24]
	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z ; ray_collider<1,1,0,0>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,0>::_stab
$LN9@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN289@stab

; 354  : 		else					_stab	(node->GetNeg());

	mov	r8, QWORD PTR [rdi]
	mov	rax, QWORD PTR [r8+32]
	lea	rdi, QWORD PTR [r8+32]

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [r8]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8+12]
	movss	xmm0, DWORD PTR [r8+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rbx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rbx+32]
	mulps	xmm4, XMMWORD PTR [rbx+48]
	mulps	xmm3, XMMWORD PTR [rbx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movaps	xmm5, xmm4
	setae	al
	comiss	xmm2, xmm4
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL284@stab

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN289@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z ; ray_collider<1,1,0,0>::_prim
$LN12@stab:

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_stab@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,1,0,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,1,0,0>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 190  : 	{

	mov	r10, rcx

; 191  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [r10+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 198  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [r10+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 198  : 		rRange2			= R*R;

	movss	DWORD PTR [r10+84], xmm0

; 199  : 		if (!bUseSSE)	{
; 200  : 			// for FPU - zero out inf
; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$00$00$0A@$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,1,0,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 64
node$ = 72
?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,1,0,1>::_stab, COMDAT

; 328  : 	{

$LN294:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	r8, rdx
	mov	rbx, rcx
	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]
	xorps	xmm6, xmm6

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [rdx+12]
	movss	xmm0, DWORD PTR [rdx+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [rdx+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm5, xmm2
	movlhps	xmm3, xmm0
	subps	xmm5, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm5, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm5, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm5
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm5, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm5, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm5

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm5, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm5, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm5
	movhlps	xmm0, xmm5

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm5, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6
	setae	al
	comiss	xmm2, xmm5
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN12@stab
$LL284@stab:

; 337  : 			if (d>rRange)																	return;

	comiss	xmm5, DWORD PTR [rbx+80]
	ja	$LN12@stab

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [r8+24]
	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z ; ray_collider<1,1,0,1>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,0,1>::_stab
$LN9@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN289@stab

; 354  : 		else					_stab	(node->GetNeg());

	mov	r8, QWORD PTR [rdi]
	mov	rax, QWORD PTR [r8+32]
	lea	rdi, QWORD PTR [r8+32]

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [r8]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8+12]
	movss	xmm0, DWORD PTR [r8+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rbx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rbx+32]
	mulps	xmm4, XMMWORD PTR [rbx+48]
	mulps	xmm3, XMMWORD PTR [rbx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movaps	xmm5, xmm4
	setae	al
	comiss	xmm2, xmm4
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL284@stab

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN289@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z ; ray_collider<1,1,0,1>::_prim
$LN12@stab:

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+64]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_stab@?$ray_collider@$00$00$0A@$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,1,0,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,1,0,1>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 190  : 	{

	mov	r10, rcx

; 191  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [r10+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 198  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [r10+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 198  : 		rRange2			= R*R;

	movss	DWORD PTR [r10+84], xmm0

; 199  : 		if (!bUseSSE)	{
; 200  : 			// for FPU - zero out inf
; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$00$00$0A@$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,1,0,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 64
node$ = 72
?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,1,1,0>::_stab, COMDAT

; 328  : 	{

$LN302:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	r8, rdx
	mov	rbx, rcx
	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]
	xorps	xmm6, xmm6

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [rdx+12]
	movss	xmm0, DWORD PTR [rdx+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [rdx+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm5, xmm2
	movlhps	xmm3, xmm0
	subps	xmm5, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm5, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm5, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm5
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm5, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm5, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm5

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm5, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm5, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm5
	movhlps	xmm0, xmm5

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm5, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6
	setae	al
	comiss	xmm2, xmm5
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN12@stab

; 231  :         return 		isect_sse	(box,ray,dist);

	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, 7905747460161236407		; 6db6db6db6db6db7H
$LL290@stab:

; 337  : 			if (d>rRange)																	return;

	comiss	xmm5, DWORD PTR [rbx+80]
	ja	$LN300@stab

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [r8+24]
	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z ; ray_collider<1,1,1,0>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,0>::_stab
$LN9@stab:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 3
	imul	rcx, rsi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 350  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	$LN300@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN296@stab

; 354  : 		else					_stab	(node->GetNeg());

	mov	r8, QWORD PTR [rdi]
	mov	rax, QWORD PTR [r8+32]
	lea	rdi, QWORD PTR [r8+32]

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [r8]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8+12]
	movss	xmm0, DWORD PTR [r8+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rbx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rbx+32]
	mulps	xmm4, XMMWORD PTR [rbx+48]
	mulps	xmm3, XMMWORD PTR [rbx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movaps	xmm5, xmm4
	setae	al
	comiss	xmm2, xmm4
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL290@stab
	jmp	SHORT $LN300@stab
$LN296@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z ; ray_collider<1,1,1,0>::_prim
$LN300@stab:
	mov	rsi, QWORD PTR [rsp+64]
$LN12@stab:

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_stab@?$ray_collider@$00$00$00$0A@@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,1,1,0>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,1,1,0>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 190  : 	{

	mov	r10, rcx

; 191  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [r10+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 198  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [r10+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 198  : 		rRange2			= R*R;

	movss	DWORD PTR [r10+84], xmm0

; 199  : 		if (!bUseSSE)	{
; 200  : 			// for FPU - zero out inf
; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$00$00$00$0A@@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,1,1,0>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z
_TEXT	SEGMENT
this$ = 64
node$ = 72
?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z PROC ; ray_collider<1,1,1,1>::_stab, COMDAT

; 328  : 	{

$LN302:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	mov	rax, QWORD PTR [rdx+32]
	lea	rdi, QWORD PTR [rdx+32]
	movaps	XMMWORD PTR [rsp+32], xmm6
	mov	r8, rdx
	mov	rbx, rcx
	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]
	xorps	xmm6, xmm6

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [rdx+12]
	movss	xmm0, DWORD PTR [rdx+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [rdx+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm5, xmm2
	movlhps	xmm3, xmm0
	subps	xmm5, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm5, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm5, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm5
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm5, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm5, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm5

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm5, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm5, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm5
	movhlps	xmm0, xmm5

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm5, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6
	setae	al
	comiss	xmm2, xmm5
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	je	$LN12@stab

; 231  :         return 		isect_sse	(box,ray,dist);

	mov	QWORD PTR [rsp+64], rsi
	mov	rsi, 7905747460161236407		; 6db6db6db6db6db7H
$LL290@stab:

; 337  : 			if (d>rRange)																	return;

	comiss	xmm5, DWORD PTR [rbx+80]
	ja	$LN300@stab

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	mov	rdx, QWORD PTR [r8+24]
	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	dl, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	je	SHORT $LN8@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 346  : 		if (node->HasLeaf())	_prim	(node->GetPrimitive());

	call	?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z ; ray_collider<1,1,1,1>::_prim
	jmp	SHORT $LN9@stab
$LN8@stab:

; 347  : 		else					_stab	(node->GetPos());

	call	?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ; ray_collider<1,1,1,1>::_stab
$LN9@stab:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rax, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rcx, QWORD PTR [rax+24]
	sub	rcx, QWORD PTR [rax+16]
	sar	rcx, 3
	imul	rcx, rsi
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 350  : 		if (bFirst && dest->r_count())														return;

	test	ecx, ecx
	jne	$LN300@stab
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	test	BYTE PTR [rdi], 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	jne	$LN296@stab

; 354  : 		else					_stab	(node->GetNeg());

	mov	r8, QWORD PTR [rdi]
	mov	rax, QWORD PTR [r8+32]
	lea	rdi, QWORD PTR [r8+32]

; 329  : 		// Should help
; 330  : 		_mm_prefetch( (char *) node->GetNeg() , _MM_HINT_NTA );

	prefetchnta BYTE PTR [rax]

; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [r8]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );
; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8+12]
	movss	xmm0, DWORD PTR [r8+8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+20]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rbx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rbx+32]
	mulps	xmm4, XMMWORD PTR [rbx+48]
	mulps	xmm3, XMMWORD PTR [rbx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm6

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movaps	xmm5, xmm4
	setae	al
	comiss	xmm2, xmm4
	movzx	edx, al
	setae	al
	movzx	ecx, al
	test	edx, ecx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 336  : 			if (!_box_sse((Fvector&)node->mAABB.mCenter,(Fvector&)node->mAABB.mExtents,d))	return;

	jne	$LL290@stab
	jmp	SHORT $LN300@stab
$LN296@stab:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	mov	rdx, QWORD PTR [rdi]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	mov	rcx, rbx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\OPC_OptimizedTree.h

; 104  : 		IMPLEMENT_NOLEAF_NODE(AABBNoLeafNode, CollisionAABB)

	shr	rdx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 353  : 		if (node->HasLeaf2())	_prim	(node->GetPrimitive2());

	call	?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z ; ray_collider<1,1,1,1>::_prim
$LN300@stab:
	mov	rsi, QWORD PTR [rsp+64]
$LN12@stab:

; 355  : 	}

	mov	rbx, QWORD PTR [rsp+72]
	movaps	xmm6, XMMWORD PTR [rsp+32]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?_stab@?$ray_collider@$00$00$00$00@@QEAAXPEBVAABBNoLeafNode@Opcode@@@Z ENDP ; ray_collider<1,1,1,1>::_stab
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_init@?$ray_collider@$00$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z
_TEXT	SEGMENT
this$ = 8
CL$ = 16
V$ = 24
T$ = 32
C$ = 40
D$ = 48
R$ = 56
?_init@?$ray_collider@$00$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z PROC ; ray_collider<1,1,1,1>::_init, COMDAT
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	xmm1, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 190  : 	{

	mov	r10, rcx

; 191  : 		dest			= CL;

	mov	QWORD PTR [rcx], rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movaps	xmm0, xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	rdx, QWORD PTR C$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 192  : 		tris			= T;

	mov	QWORD PTR [rcx+8], r9

; 193  : 		verts			= V;

	mov	QWORD PTR [rcx+16], r8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rdx]
	mov	DWORD PTR [rcx+32], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+36], eax
	mov	eax, DWORD PTR [rdx+8]

; 24   :     ICF SelfRef set(T _x, T _y, T _z) { x = _x; y = _y; z = _z; return *this; };

	mov	DWORD PTR [rcx+48], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+52], 1065353216		; 3f800000H
	mov	DWORD PTR [rcx+56], 1065353216		; 3f800000H

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [rcx+40], eax

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	mov	rcx, QWORD PTR D$[rsp]
	divss	xmm0, DWORD PTR [rcx]
	movss	DWORD PTR [r10+48], xmm0
	movaps	xmm0, xmm1
	divss	xmm0, DWORD PTR [rcx+4]
	movss	DWORD PTR [r10+52], xmm0
	divss	xmm1, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	xmm0, DWORD PTR R$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 45   :     ICF SelfRef div(const Self& v) { x /= v.x; y /= v.y; z /= v.z; return *this; };

	movss	DWORD PTR [r10+56], xmm1

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	eax, DWORD PTR [rcx]
	mov	DWORD PTR [r10+64], eax
	mov	eax, DWORD PTR [rcx+4]
	mov	DWORD PTR [r10+68], eax
	mov	eax, DWORD PTR [rcx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 197  : 		rRange			= R;

	movss	DWORD PTR [r10+80], xmm0

; 198  : 		rRange2			= R*R;

	mulss	xmm0, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 25   :     ICF SelfRef set(const _vector3<float>& v) { x = T(v.x); y = T(v.y); z = T(v.z); return *this; };

	mov	DWORD PTR [r10+72], eax
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 198  : 		rRange2			= R*R;

	movss	DWORD PTR [r10+84], xmm0

; 199  : 		if (!bUseSSE)	{
; 200  : 			// for FPU - zero out inf
; 201  : 			if (_abs(D.x)>flt_eps){}	else ray.inv_dir.x=0;
; 202  : 			if (_abs(D.y)>flt_eps){}	else ray.inv_dir.y=0;
; 203  : 			if (_abs(D.z)>flt_eps){}	else ray.inv_dir.z=0;
; 204  : 		}
; 205  : 	}

	ret	0
?_init@?$ray_collider@$00$00$00$00@@QEAAXPEAVCOLLIDER@CDB@@PEAU?$_vector3@M@@PEAVTRI@3@AEBU4@3M@Z ENDP ; ray_collider<1,1,1,1>::_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z
_TEXT	SEGMENT
tv1073 = 208
this$ = 208
tv1031 = 216
prim$ = 216
?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z PROC	; ray_collider<0,0,0,0>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+64], xmm13
	movaps	XMMWORD PTR [rsp+48], xmm14
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	mov	esi, edx
	movaps	XMMWORD PTR [rsp+32], xmm15

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [r10+r9*4+4]
	movss	xmm9, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm1, DWORD PTR [r10+rdx*4]
	movss	xmm15, DWORD PTR [r10+rdx*4+8]
	subss	xmm1, xmm9
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm15, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r10+rcx*4+4]
	subss	xmm2, xmm10
	movss	xmm13, DWORD PTR [r10+rcx*4+8]
	subss	xmm6, xmm10
	movss	xmm12, DWORD PTR [r10+rcx*4]
	subss	xmm13, DWORD PTR [r10+r9*4+8]
	subss	xmm12, xmm9
	movss	DWORD PTR tv1073[rsp], xmm1

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm4, xmm6
	mulss	xmm0, DWORD PTR [rbx+72]
	mulss	xmm4, DWORD PTR [rbx+64]
	movaps	xmm14, xmm13
	mulss	xmm14, xmm8
	movaps	xmm7, xmm12
	mulss	xmm7, DWORD PTR [rbx+72]
	subss	xmm14, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rbx+64]
	subss	xmm7, xmm0
	movaps	xmm0, xmm12
	mulss	xmm0, xmm8
	subss	xmm4, xmm0
	movaps	xmm3, xmm7
	mulss	xmm3, xmm2

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm14
	mulss	xmm0, xmm1
	movaps	xmm1, xmm15
	mulss	xmm1, xmm4
	addss	xmm3, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv1031[rsp], xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm3, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN59@prim
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm3
	ja	$LN4@prim
$LN59@prim:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+32]
	subss	xmm5, xmm9
	movaps	XMMWORD PTR [rsp+96], xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm11, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+36]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movaps	xmm4, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm9, xmm10
	movss	xmm10, DWORD PTR [rbx+40]
	subss	xmm10, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm14, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm4, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm10
	mulss	xmm0, DWORD PTR tv1031[rsp]
	addss	xmm7, xmm14
	xorps	xmm14, xmm14
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm7, xmm4

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm14, xmm7
	ja	$LN62@prim
	comiss	xmm7, xmm11
	ja	$LN62@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm1, xmm15
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm15, xmm5
	mulss	xmm2, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm5, DWORD PTR [rbx+72]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm1, xmm9
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1073[rsp]
	movaps	xmm3, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, xmm9
	mulss	xmm3, xmm10
	subss	xmm2, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm0, DWORD PTR [rbx+64]
	mulss	xmm0, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm3, xmm15

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm5, xmm2
	mulss	xmm8, xmm3
	addss	xmm8, xmm0
	addss	xmm8, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm8, xmm4

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm14, xmm8
	ja	$LN62@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm11
	ja	$LN62@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm6, xmm3
	mulss	xmm12, xmm1
	mulss	xmm13, xmm2
	addss	xmm6, xmm12
	addss	xmm6, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm6, xmm4

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm14, xmm6
	jae	$LN62@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN62@prim

; 284  : 		
; 285  : 		if (bNearest)	
; 286  : 		{
; 287  : 			if (dest->r_count())	
; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{
; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;
; 293  : 					R.u			= u;
; 294  : 					R.v			= v;
; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 298  : 					R.dummy		= tris[prim].dummy;
; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {
; 303  : 				RESULT& R	= dest->r_add();
; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;
; 306  : 				R.u			= u;
; 307  : 				R.v			= v;
; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 311  : 				R.dummy		= tris[prim].dummy;
; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 319  : 			R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 320  : 			R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 324  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:
	movaps	xmm11, XMMWORD PTR [rsp+96]
$LN4@prim:

; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAXK@Z ENDP	; ray_collider<0,0,0,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,0,0,0>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,0,0,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,0,0,0>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,0,0,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z
_TEXT	SEGMENT
tv1031 = 224
this$ = 224
tv1026 = 232
prim$ = 232
tv1032 = 240
tv1029 = 248
?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z PROC	; ray_collider<0,0,0,1>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	rax, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-88], xmm9
	movaps	xmm9, xmm8
	movaps	XMMWORD PTR [rax-104], xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movss	xmm10, DWORD PTR [rbx+64]
	movaps	XMMWORD PTR [rax-120], xmm11

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm11, DWORD PTR [rbx+72]
	movaps	XMMWORD PTR [rsp+80], xmm12
	movaps	xmm0, xmm11
	movaps	XMMWORD PTR [rsp+64], xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	movaps	XMMWORD PTR [rsp+32], xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm15, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 280  : 	{

	mov	esi, edx

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm7, DWORD PTR [r10+r9*4+4]
	movss	xmm6, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm12, DWORD PTR [r10+rdx*4]
	movss	xmm13, DWORD PTR [r10+rdx*4+4]
	subss	xmm12, xmm6
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm13, xmm7
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm1, DWORD PTR [r10+rcx*4+8]
	subss	xmm1, DWORD PTR [r10+r9*4+8]
	movss	xmm2, DWORD PTR [r10+rcx*4]
	movss	xmm3, DWORD PTR [r10+rcx*4+4]
	subss	xmm2, xmm6
	subss	xmm3, xmm7

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm9, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm15, xmm2
	mulss	xmm0, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1029[rsp], xmm1
	movss	DWORD PTR tv1032[rsp], xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	subss	xmm9, xmm0

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1031[rsp], xmm3

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm0, xmm10
	mulss	xmm0, xmm1

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm10
	mulss	xmm1, xmm3
	subss	xmm15, xmm0
	movaps	xmm0, xmm8
	mulss	xmm0, xmm2
	subss	xmm1, xmm0
	movaps	xmm2, xmm15
	mulss	xmm2, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm9
	mulss	xmm0, xmm12

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv1026[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm14
	addss	xmm2, xmm0
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN61@prim
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN8@prim
$LN61@prim:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+36]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm5, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm3, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movaps	xmm4, xmm5
	divss	xmm4, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rbx+32]
	movaps	xmm7, xmm3
	subss	xmm2, xmm6
	mulss	xmm7, xmm15
	movss	xmm6, DWORD PTR [rbx+40]
	subss	xmm6, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm9
	xorps	xmm9, xmm9
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR tv1026[rsp]
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm7, xmm4

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm7
	ja	$LN8@prim
	comiss	xmm7, xmm5
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm13
	mulss	xmm1, xmm14
	mulss	xmm6, xmm12
	subss	xmm1, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm12
	movaps	xmm0, xmm2
	mulss	xmm2, xmm13
	mulss	xmm0, xmm14
	subss	xmm2, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm10, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm6, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm11, xmm2
	mulss	xmm8, xmm6
	addss	xmm8, xmm10
	addss	xmm8, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm8, xmm4

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm8
	ja	$LN8@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm5
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm6, DWORD PTR tv1031[rsp]
	mulss	xmm1, DWORD PTR tv1032[rsp]
	mulss	xmm2, DWORD PTR tv1029[rsp]
	addss	xmm6, xmm1
	addss	xmm6, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm6, xmm4

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm9, xmm6
	jae	$LN8@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN8@prim
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	mov	r8, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+24]
	sub	rax, r8
	sar	rax, 3
	imul	rax, rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 287  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN7@prim

; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{

	movss	xmm0, DWORD PTR [r8+44]
	comiss	xmm0, xmm6
	jbe	$LN8@prim

; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;

	movss	DWORD PTR [r8+44], xmm6

; 293  : 					R.u			= u;

	movss	DWORD PTR [r8+48], xmm7

; 294  : 					R.v			= v;

	movss	DWORD PTR [r8+52], xmm8
	mov	DWORD PTR [r8+40], esi

; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 298  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r8+36], ecx

; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {

	jmp	$LN62@prim
$LN7@prim:

; 303  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 306  : 				R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 307  : 				R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 311  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:

; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();
; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;
; 319  : 			R.u			= u;
; 320  : 			R.v			= v;
; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 324  : 			R.dummy		= tris[prim].dummy;
; 325  : 		}
; 326  : 	}

	movss	DWORD PTR [rbx+80], xmm6
	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN8@prim:
	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$0A@$0A@$00@@QEAAXK@Z ENDP	; ray_collider<0,0,0,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,0,0,1>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,0,0,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,0,0,1>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,0,0,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z
_TEXT	SEGMENT
tv1073 = 208
this$ = 208
tv1031 = 216
prim$ = 216
?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z PROC	; ray_collider<0,0,1,0>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+64], xmm13
	movaps	XMMWORD PTR [rsp+48], xmm14
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	mov	esi, edx
	movaps	XMMWORD PTR [rsp+32], xmm15

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [r10+r9*4+4]
	movss	xmm9, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm1, DWORD PTR [r10+rdx*4]
	movss	xmm15, DWORD PTR [r10+rdx*4+8]
	subss	xmm1, xmm9
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm15, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r10+rcx*4+4]
	subss	xmm2, xmm10
	movss	xmm13, DWORD PTR [r10+rcx*4+8]
	subss	xmm6, xmm10
	movss	xmm12, DWORD PTR [r10+rcx*4]
	subss	xmm13, DWORD PTR [r10+r9*4+8]
	subss	xmm12, xmm9
	movss	DWORD PTR tv1073[rsp], xmm1

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm4, xmm6
	mulss	xmm0, DWORD PTR [rbx+72]
	mulss	xmm4, DWORD PTR [rbx+64]
	movaps	xmm14, xmm13
	mulss	xmm14, xmm8
	movaps	xmm7, xmm12
	mulss	xmm7, DWORD PTR [rbx+72]
	subss	xmm14, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rbx+64]
	subss	xmm7, xmm0
	movaps	xmm0, xmm12
	mulss	xmm0, xmm8
	subss	xmm4, xmm0
	movaps	xmm3, xmm7
	mulss	xmm3, xmm2

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm14
	mulss	xmm0, xmm1
	movaps	xmm1, xmm15
	mulss	xmm1, xmm4
	addss	xmm3, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv1031[rsp], xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm3, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN59@prim
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm3
	ja	$LN4@prim
$LN59@prim:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+32]
	subss	xmm5, xmm9
	movaps	XMMWORD PTR [rsp+96], xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm11, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+36]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movaps	xmm4, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm9, xmm10
	movss	xmm10, DWORD PTR [rbx+40]
	subss	xmm10, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm14, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm4, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm10
	mulss	xmm0, DWORD PTR tv1031[rsp]
	addss	xmm7, xmm14
	xorps	xmm14, xmm14
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm7, xmm4

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm14, xmm7
	ja	$LN62@prim
	comiss	xmm7, xmm11
	ja	$LN62@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm1, xmm15
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm15, xmm5
	mulss	xmm2, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm5, DWORD PTR [rbx+72]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm1, xmm9
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1073[rsp]
	movaps	xmm3, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, xmm9
	mulss	xmm3, xmm10
	subss	xmm2, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm0, DWORD PTR [rbx+64]
	mulss	xmm0, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm3, xmm15

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm5, xmm2
	mulss	xmm8, xmm3
	addss	xmm8, xmm0
	addss	xmm8, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm8, xmm4

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm14, xmm8
	ja	$LN62@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm11
	ja	$LN62@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm6, xmm3
	mulss	xmm12, xmm1
	mulss	xmm13, xmm2
	addss	xmm6, xmm12
	addss	xmm6, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm6, xmm4

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm14, xmm6
	jae	$LN62@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN62@prim

; 284  : 		
; 285  : 		if (bNearest)	
; 286  : 		{
; 287  : 			if (dest->r_count())	
; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{
; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;
; 293  : 					R.u			= u;
; 294  : 					R.v			= v;
; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 298  : 					R.dummy		= tris[prim].dummy;
; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {
; 303  : 				RESULT& R	= dest->r_add();
; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;
; 306  : 				R.u			= u;
; 307  : 				R.v			= v;
; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 311  : 				R.dummy		= tris[prim].dummy;
; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 319  : 			R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 320  : 			R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 324  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:
	movaps	xmm11, XMMWORD PTR [rsp+96]
$LN4@prim:

; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$ray_collider@$0A@$0A@$00$0A@@@QEAAXK@Z ENDP	; ray_collider<0,0,1,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,0,1,0>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,0,1,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,0,1,0>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,0,1,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z
_TEXT	SEGMENT
tv1031 = 224
this$ = 224
tv1026 = 232
prim$ = 232
tv1032 = 240
tv1029 = 248
?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z PROC	; ray_collider<0,0,1,1>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	rax, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-88], xmm9
	movaps	xmm9, xmm8
	movaps	XMMWORD PTR [rax-104], xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movss	xmm10, DWORD PTR [rbx+64]
	movaps	XMMWORD PTR [rax-120], xmm11

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm11, DWORD PTR [rbx+72]
	movaps	XMMWORD PTR [rsp+80], xmm12
	movaps	xmm0, xmm11
	movaps	XMMWORD PTR [rsp+64], xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	movaps	XMMWORD PTR [rsp+32], xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm15, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 280  : 	{

	mov	esi, edx

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm7, DWORD PTR [r10+r9*4+4]
	movss	xmm6, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm12, DWORD PTR [r10+rdx*4]
	movss	xmm13, DWORD PTR [r10+rdx*4+4]
	subss	xmm12, xmm6
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm13, xmm7
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm1, DWORD PTR [r10+rcx*4+8]
	subss	xmm1, DWORD PTR [r10+r9*4+8]
	movss	xmm2, DWORD PTR [r10+rcx*4]
	movss	xmm3, DWORD PTR [r10+rcx*4+4]
	subss	xmm2, xmm6
	subss	xmm3, xmm7

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm9, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm15, xmm2
	mulss	xmm0, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1029[rsp], xmm1
	movss	DWORD PTR tv1032[rsp], xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	subss	xmm9, xmm0

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1031[rsp], xmm3

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm0, xmm10
	mulss	xmm0, xmm1

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm10
	mulss	xmm1, xmm3
	subss	xmm15, xmm0
	movaps	xmm0, xmm8
	mulss	xmm0, xmm2
	subss	xmm1, xmm0
	movaps	xmm2, xmm15
	mulss	xmm2, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm9
	mulss	xmm0, xmm12

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv1026[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm14
	addss	xmm2, xmm0
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN61@prim
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN8@prim
$LN61@prim:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+36]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm5, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm3, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movaps	xmm4, xmm5
	divss	xmm4, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rbx+32]
	movaps	xmm7, xmm3
	subss	xmm2, xmm6
	mulss	xmm7, xmm15
	movss	xmm6, DWORD PTR [rbx+40]
	subss	xmm6, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm9
	xorps	xmm9, xmm9
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR tv1026[rsp]
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm7, xmm4

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm7
	ja	$LN8@prim
	comiss	xmm7, xmm5
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm13
	mulss	xmm1, xmm14
	mulss	xmm6, xmm12
	subss	xmm1, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm12
	movaps	xmm0, xmm2
	mulss	xmm2, xmm13
	mulss	xmm0, xmm14
	subss	xmm2, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm10, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm6, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm11, xmm2
	mulss	xmm8, xmm6
	addss	xmm8, xmm10
	addss	xmm8, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm8, xmm4

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm8
	ja	$LN8@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm5
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm6, DWORD PTR tv1031[rsp]
	mulss	xmm1, DWORD PTR tv1032[rsp]
	mulss	xmm2, DWORD PTR tv1029[rsp]
	addss	xmm6, xmm1
	addss	xmm6, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm6, xmm4

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm9, xmm6
	jae	$LN8@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN8@prim
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	mov	r8, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+24]
	sub	rax, r8
	sar	rax, 3
	imul	rax, rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 287  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN7@prim

; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{

	movss	xmm0, DWORD PTR [r8+44]
	comiss	xmm0, xmm6
	jbe	$LN8@prim

; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;

	movss	DWORD PTR [r8+44], xmm6

; 293  : 					R.u			= u;

	movss	DWORD PTR [r8+48], xmm7

; 294  : 					R.v			= v;

	movss	DWORD PTR [r8+52], xmm8
	mov	DWORD PTR [r8+40], esi

; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 298  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r8+36], ecx

; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {

	jmp	$LN62@prim
$LN7@prim:

; 303  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 306  : 				R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 307  : 				R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 311  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:

; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();
; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;
; 319  : 			R.u			= u;
; 320  : 			R.v			= v;
; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 324  : 			R.dummy		= tris[prim].dummy;
; 325  : 		}
; 326  : 	}

	movss	DWORD PTR [rbx+80], xmm6
	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN8@prim:
	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$0A@$00$00@@QEAAXK@Z ENDP	; ray_collider<0,0,1,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,0,1,1>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,0,1,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,0,1,1>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,0,1,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z
_TEXT	SEGMENT
this$ = 208
prim$ = 216
?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z PROC	; ray_collider<0,1,0,0>::_prim, COMDAT

; 280  : 	{

$LN61:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+64], xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	mov	esi, edx
	movaps	XMMWORD PTR [rsp+32], xmm15

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [r10+r9*4+4]
	movss	xmm9, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm15, DWORD PTR [r10+rdx*4]
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm15, xmm9
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm2, xmm10
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r10+rcx*4+4]
	movss	xmm12, DWORD PTR [r10+rcx*4+8]
	subss	xmm6, xmm10
	movss	xmm11, DWORD PTR [r10+rcx*4]
	subss	xmm12, DWORD PTR [r10+r9*4+8]
	subss	xmm11, xmm9

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm13, xmm6
	mulss	xmm0, DWORD PTR [rbx+72]
	mulss	xmm13, DWORD PTR [rbx+64]
	movaps	xmm3, xmm12
	mulss	xmm3, xmm8
	movaps	xmm7, xmm11
	mulss	xmm7, DWORD PTR [rbx+72]
	subss	xmm3, xmm0
	movaps	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+64]
	subss	xmm7, xmm0
	movaps	xmm0, xmm11
	mulss	xmm0, xmm8
	subss	xmm13, xmm0
	movaps	xmm4, xmm7

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm2

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm15
	movaps	xmm1, xmm13
	mulss	xmm1, xmm14
	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm4
	ja	$LN4@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+32]
	subss	xmm5, xmm9
	movss	xmm9, DWORD PTR [rbx+36]
	subss	xmm9, xmm10
	movss	xmm10, DWORD PTR [rbx+40]
	subss	xmm10, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm3, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm13, xmm10
	addss	xmm7, xmm3
	addss	xmm7, xmm13
	xorps	xmm13, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm13, xmm7
	ja	$LN4@prim
	comiss	xmm7, xmm4
	ja	$LN4@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm1, xmm14
	mulss	xmm0, xmm10
	movaps	xmm3, xmm15

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm14, xmm5
	mulss	xmm2, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm5, DWORD PTR [rbx+72]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm1, xmm9
	mulss	xmm3, xmm10
	subss	xmm1, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm15, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm0, DWORD PTR [rbx+64]

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm3, xmm14

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	subss	xmm2, xmm15

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm1
	mulss	xmm8, xmm3
	mulss	xmm5, xmm2
	addss	xmm8, xmm0
	addss	xmm8, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm13, xmm8
	ja	$LN4@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm4
	ja	$LN4@prim

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm4
	mulss	xmm6, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm11, xmm1
	mulss	xmm12, xmm2
	addss	xmm6, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm7, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm8, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm12
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 260  : 			range	*= inv_det;

	mulss	xmm6, xmm0

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm13, xmm6
	jae	$LN4@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN4@prim

; 284  : 		
; 285  : 		if (bNearest)	
; 286  : 		{
; 287  : 			if (dest->r_count())	
; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{
; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;
; 293  : 					R.u			= u;
; 294  : 					R.v			= v;
; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 298  : 					R.dummy		= tris[prim].dummy;
; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {
; 303  : 				RESULT& R	= dest->r_add();
; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;
; 306  : 				R.u			= u;
; 307  : 				R.v			= v;
; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 311  : 				R.dummy		= tris[prim].dummy;
; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 319  : 			R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 320  : 			R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 324  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN4@prim:

; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$ray_collider@$0A@$00$0A@$0A@@@QEAAXK@Z ENDP	; ray_collider<0,1,0,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,1,0,0>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,1,0,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,1,0,0>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,1,0,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z
_TEXT	SEGMENT
tv1031 = 224
this$ = 224
tv1030 = 232
prim$ = 232
tv1029 = 240
?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z PROC	; ray_collider<0,1,0,1>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	r11, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [r11-40], xmm6
	movaps	XMMWORD PTR [r11-56], xmm7
	movaps	XMMWORD PTR [r11-72], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [r11-104], xmm10
	movaps	xmm6, xmm8
	movaps	XMMWORD PTR [r11-120], xmm11
	movaps	XMMWORD PTR [rsp+80], xmm12

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movss	xmm12, DWORD PTR [rbx+64]
	movaps	XMMWORD PTR [rsp+64], xmm13

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm13, DWORD PTR [rbx+72]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	movaps	XMMWORD PTR [rsp+32], xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm10, xmm13

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm15, xmm12
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 280  : 	{

	mov	esi, edx

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm7, DWORD PTR [r10+r9*4+4]
	movss	xmm5, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm11, DWORD PTR [r10+rdx*4]
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm11, xmm5
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm2, xmm7
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r10+rcx*4+4]
	movss	xmm1, DWORD PTR [r10+rcx*4]
	subss	xmm3, xmm7
	movss	xmm4, DWORD PTR [r10+rcx*4+8]
	subss	xmm1, xmm5
	subss	xmm4, DWORD PTR [r10+r9*4+8]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm0, xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm15, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1030[rsp], xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm3, xmm2
	mulss	xmm10, xmm1

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1031[rsp], xmm1

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm6, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1029[rsp], xmm4

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	subss	xmm6, xmm0

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm0, xmm12
	mulss	xmm0, xmm4
	subss	xmm10, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm8
	mulss	xmm0, xmm1
	subss	xmm15, xmm0
	mulss	xmm3, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm11
	mulss	xmm0, xmm6
	movaps	xmm1, xmm15
	mulss	xmm1, xmm14
	addss	xmm3, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm3
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rbx+32]
	subss	xmm4, xmm5
	movaps	XMMWORD PTR [r11-88], xmm9
	movss	xmm5, DWORD PTR [rbx+36]
	movss	xmm9, DWORD PTR [rbx+40]
	subss	xmm5, xmm7
	subss	xmm9, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm9

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm10
	xorps	xmm10, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm15
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm10, xmm7
	ja	$LN61@prim
	comiss	xmm7, xmm3
	ja	$LN61@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm6, xmm11
	mulss	xmm0, xmm9
	movaps	xmm1, xmm5
	mulss	xmm1, xmm14
	mulss	xmm6, xmm9
	subss	xmm1, xmm0

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm2, xmm4
	movaps	xmm0, xmm4

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm11, xmm5
	mulss	xmm0, xmm14
	subss	xmm2, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm12, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm6, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm13, xmm2
	mulss	xmm8, xmm6
	addss	xmm8, xmm12
	addss	xmm8, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm10, xmm8
	ja	$LN61@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm3
	ja	$LN61@prim

; 259  : 			inv_det = 1.0f / det;

	mulss	xmm6, DWORD PTR tv1030[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, DWORD PTR tv1031[rsp]
	mulss	xmm2, DWORD PTR tv1029[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 259  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm7, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm8, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 260  : 			range	*= inv_det;

	mulss	xmm6, xmm0

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm10, xmm6
	jae	$LN61@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN61@prim
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	mov	r8, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+24]
	sub	rax, r8
	sar	rax, 3
	imul	rax, rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 287  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN7@prim

; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{

	movss	xmm0, DWORD PTR [r8+44]
	comiss	xmm0, xmm6
	jbe	$LN61@prim

; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;

	movss	DWORD PTR [r8+44], xmm6

; 293  : 					R.u			= u;

	movss	DWORD PTR [r8+48], xmm7

; 294  : 					R.v			= v;

	movss	DWORD PTR [r8+52], xmm8
	mov	DWORD PTR [r8+40], esi

; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 298  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r8+36], ecx

; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {

	jmp	$LN62@prim
$LN7@prim:

; 303  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 306  : 				R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 307  : 				R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 311  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:

; 312  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 313  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN61@prim:
	movaps	xmm9, XMMWORD PTR [rsp+128]
$LN8@prim:

; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();
; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;
; 319  : 			R.u			= u;
; 320  : 			R.v			= v;
; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 324  : 			R.dummy		= tris[prim].dummy;
; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$00$0A@$00@@QEAAXK@Z ENDP	; ray_collider<0,1,0,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,1,0,1>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,1,0,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,1,0,1>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,1,0,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z
_TEXT	SEGMENT
this$ = 208
prim$ = 216
?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z PROC	; ray_collider<0,1,1,0>::_prim, COMDAT

; 280  : 	{

$LN61:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+64], xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	mov	esi, edx
	movaps	XMMWORD PTR [rsp+32], xmm15

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [r10+r9*4+4]
	movss	xmm9, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm15, DWORD PTR [r10+rdx*4]
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm15, xmm9
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm2, xmm10
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r10+rcx*4+4]
	movss	xmm12, DWORD PTR [r10+rcx*4+8]
	subss	xmm6, xmm10
	movss	xmm11, DWORD PTR [r10+rcx*4]
	subss	xmm12, DWORD PTR [r10+r9*4+8]
	subss	xmm11, xmm9

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm13, xmm6
	mulss	xmm0, DWORD PTR [rbx+72]
	mulss	xmm13, DWORD PTR [rbx+64]
	movaps	xmm3, xmm12
	mulss	xmm3, xmm8
	movaps	xmm7, xmm11
	mulss	xmm7, DWORD PTR [rbx+72]
	subss	xmm3, xmm0
	movaps	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+64]
	subss	xmm7, xmm0
	movaps	xmm0, xmm11
	mulss	xmm0, xmm8
	subss	xmm13, xmm0
	movaps	xmm4, xmm7

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm2

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm15
	movaps	xmm1, xmm13
	mulss	xmm1, xmm14
	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm4
	ja	$LN4@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+32]
	subss	xmm5, xmm9
	movss	xmm9, DWORD PTR [rbx+36]
	subss	xmm9, xmm10
	movss	xmm10, DWORD PTR [rbx+40]
	subss	xmm10, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm3, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm13, xmm10
	addss	xmm7, xmm3
	addss	xmm7, xmm13
	xorps	xmm13, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm13, xmm7
	ja	$LN4@prim
	comiss	xmm7, xmm4
	ja	$LN4@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm1, xmm14
	mulss	xmm0, xmm10
	movaps	xmm3, xmm15

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm14, xmm5
	mulss	xmm2, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm5, DWORD PTR [rbx+72]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm1, xmm9
	mulss	xmm3, xmm10
	subss	xmm1, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm15, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm0, DWORD PTR [rbx+64]

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm3, xmm14

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	subss	xmm2, xmm15

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm1
	mulss	xmm8, xmm3
	mulss	xmm5, xmm2
	addss	xmm8, xmm0
	addss	xmm8, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm13, xmm8
	ja	$LN4@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm4
	ja	$LN4@prim

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm4
	mulss	xmm6, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm11, xmm1
	mulss	xmm12, xmm2
	addss	xmm6, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm7, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm8, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm12
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 260  : 			range	*= inv_det;

	mulss	xmm6, xmm0

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm13, xmm6
	jae	$LN4@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN4@prim

; 284  : 		
; 285  : 		if (bNearest)	
; 286  : 		{
; 287  : 			if (dest->r_count())	
; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{
; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;
; 293  : 					R.u			= u;
; 294  : 					R.v			= v;
; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 298  : 					R.dummy		= tris[prim].dummy;
; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {
; 303  : 				RESULT& R	= dest->r_add();
; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;
; 306  : 				R.u			= u;
; 307  : 				R.v			= v;
; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 311  : 				R.dummy		= tris[prim].dummy;
; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 319  : 			R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 320  : 			R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 324  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN4@prim:

; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$ray_collider@$0A@$00$00$0A@@@QEAAXK@Z ENDP	; ray_collider<0,1,1,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,1,1,0>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,1,1,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,1,1,0>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,1,1,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z
_TEXT	SEGMENT
tv1031 = 224
this$ = 224
tv1030 = 232
prim$ = 232
tv1029 = 240
?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z PROC	; ray_collider<0,1,1,1>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	r11, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [r11-40], xmm6
	movaps	XMMWORD PTR [r11-56], xmm7
	movaps	XMMWORD PTR [r11-72], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [r11-104], xmm10
	movaps	xmm6, xmm8
	movaps	XMMWORD PTR [r11-120], xmm11
	movaps	XMMWORD PTR [rsp+80], xmm12

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movss	xmm12, DWORD PTR [rbx+64]
	movaps	XMMWORD PTR [rsp+64], xmm13

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm13, DWORD PTR [rbx+72]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	movaps	XMMWORD PTR [rsp+32], xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm10, xmm13

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm15, xmm12
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 280  : 	{

	mov	esi, edx

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm7, DWORD PTR [r10+r9*4+4]
	movss	xmm5, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm11, DWORD PTR [r10+rdx*4]
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm11, xmm5
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm2, xmm7
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r10+rcx*4+4]
	movss	xmm1, DWORD PTR [r10+rcx*4]
	subss	xmm3, xmm7
	movss	xmm4, DWORD PTR [r10+rcx*4+8]
	subss	xmm1, xmm5
	subss	xmm4, DWORD PTR [r10+r9*4+8]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm0, xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm15, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1030[rsp], xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm3, xmm2
	mulss	xmm10, xmm1

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1031[rsp], xmm1

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm6, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1029[rsp], xmm4

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	subss	xmm6, xmm0

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm0, xmm12
	mulss	xmm0, xmm4
	subss	xmm10, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm8
	mulss	xmm0, xmm1
	subss	xmm15, xmm0
	mulss	xmm3, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm11
	mulss	xmm0, xmm6
	movaps	xmm1, xmm15
	mulss	xmm1, xmm14
	addss	xmm3, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm3
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rbx+32]
	subss	xmm4, xmm5
	movaps	XMMWORD PTR [r11-88], xmm9
	movss	xmm5, DWORD PTR [rbx+36]
	movss	xmm9, DWORD PTR [rbx+40]
	subss	xmm5, xmm7
	subss	xmm9, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm9

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm10
	xorps	xmm10, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm15
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm10, xmm7
	ja	$LN61@prim
	comiss	xmm7, xmm3
	ja	$LN61@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm6, xmm11
	mulss	xmm0, xmm9
	movaps	xmm1, xmm5
	mulss	xmm1, xmm14
	mulss	xmm6, xmm9
	subss	xmm1, xmm0

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm2, xmm4
	movaps	xmm0, xmm4

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm11, xmm5
	mulss	xmm0, xmm14
	subss	xmm2, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm12, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm6, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm13, xmm2
	mulss	xmm8, xmm6
	addss	xmm8, xmm12
	addss	xmm8, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm10, xmm8
	ja	$LN61@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm3
	ja	$LN61@prim

; 259  : 			inv_det = 1.0f / det;

	mulss	xmm6, DWORD PTR tv1030[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, DWORD PTR tv1031[rsp]
	mulss	xmm2, DWORD PTR tv1029[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 259  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm7, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm8, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 260  : 			range	*= inv_det;

	mulss	xmm6, xmm0

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm10, xmm6
	jae	$LN61@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN61@prim
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	mov	r8, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+24]
	sub	rax, r8
	sar	rax, 3
	imul	rax, rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 287  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN7@prim

; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{

	movss	xmm0, DWORD PTR [r8+44]
	comiss	xmm0, xmm6
	jbe	$LN61@prim

; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;

	movss	DWORD PTR [r8+44], xmm6

; 293  : 					R.u			= u;

	movss	DWORD PTR [r8+48], xmm7

; 294  : 					R.v			= v;

	movss	DWORD PTR [r8+52], xmm8
	mov	DWORD PTR [r8+40], esi

; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 298  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r8+36], ecx

; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {

	jmp	$LN62@prim
$LN7@prim:

; 303  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 306  : 				R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 307  : 				R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 311  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:

; 312  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 313  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN61@prim:
	movaps	xmm9, XMMWORD PTR [rsp+128]
$LN8@prim:

; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();
; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;
; 319  : 			R.u			= u;
; 320  : 			R.v			= v;
; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 324  : 			R.dummy		= tris[prim].dummy;
; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$0A@$00$00$00@@QEAAXK@Z ENDP	; ray_collider<0,1,1,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<0,1,1,1>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<0,1,1,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<0,1,1,1>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$0A@$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<0,1,1,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z
_TEXT	SEGMENT
tv1073 = 208
this$ = 208
tv1031 = 216
prim$ = 216
?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z PROC	; ray_collider<1,0,0,0>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+64], xmm13
	movaps	XMMWORD PTR [rsp+48], xmm14
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	mov	esi, edx
	movaps	XMMWORD PTR [rsp+32], xmm15

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [r10+r9*4+4]
	movss	xmm9, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm1, DWORD PTR [r10+rdx*4]
	movss	xmm15, DWORD PTR [r10+rdx*4+8]
	subss	xmm1, xmm9
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm15, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r10+rcx*4+4]
	subss	xmm2, xmm10
	movss	xmm13, DWORD PTR [r10+rcx*4+8]
	subss	xmm6, xmm10
	movss	xmm12, DWORD PTR [r10+rcx*4]
	subss	xmm13, DWORD PTR [r10+r9*4+8]
	subss	xmm12, xmm9
	movss	DWORD PTR tv1073[rsp], xmm1

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm4, xmm6
	mulss	xmm0, DWORD PTR [rbx+72]
	mulss	xmm4, DWORD PTR [rbx+64]
	movaps	xmm14, xmm13
	mulss	xmm14, xmm8
	movaps	xmm7, xmm12
	mulss	xmm7, DWORD PTR [rbx+72]
	subss	xmm14, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rbx+64]
	subss	xmm7, xmm0
	movaps	xmm0, xmm12
	mulss	xmm0, xmm8
	subss	xmm4, xmm0
	movaps	xmm3, xmm7
	mulss	xmm3, xmm2

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm14
	mulss	xmm0, xmm1
	movaps	xmm1, xmm15
	mulss	xmm1, xmm4
	addss	xmm3, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv1031[rsp], xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm3, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN59@prim
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm3
	ja	$LN4@prim
$LN59@prim:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+32]
	subss	xmm5, xmm9
	movaps	XMMWORD PTR [rsp+96], xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm11, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+36]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movaps	xmm4, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm9, xmm10
	movss	xmm10, DWORD PTR [rbx+40]
	subss	xmm10, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm14, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm4, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm10
	mulss	xmm0, DWORD PTR tv1031[rsp]
	addss	xmm7, xmm14
	xorps	xmm14, xmm14
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm7, xmm4

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm14, xmm7
	ja	$LN62@prim
	comiss	xmm7, xmm11
	ja	$LN62@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm1, xmm15
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm15, xmm5
	mulss	xmm2, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm5, DWORD PTR [rbx+72]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm1, xmm9
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1073[rsp]
	movaps	xmm3, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, xmm9
	mulss	xmm3, xmm10
	subss	xmm2, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm0, DWORD PTR [rbx+64]
	mulss	xmm0, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm3, xmm15

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm5, xmm2
	mulss	xmm8, xmm3
	addss	xmm8, xmm0
	addss	xmm8, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm8, xmm4

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm14, xmm8
	ja	$LN62@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm11
	ja	$LN62@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm6, xmm3
	mulss	xmm12, xmm1
	mulss	xmm13, xmm2
	addss	xmm6, xmm12
	addss	xmm6, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm6, xmm4

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm14, xmm6
	jae	$LN62@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN62@prim

; 284  : 		
; 285  : 		if (bNearest)	
; 286  : 		{
; 287  : 			if (dest->r_count())	
; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{
; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;
; 293  : 					R.u			= u;
; 294  : 					R.v			= v;
; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 298  : 					R.dummy		= tris[prim].dummy;
; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {
; 303  : 				RESULT& R	= dest->r_add();
; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;
; 306  : 				R.u			= u;
; 307  : 				R.v			= v;
; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 311  : 				R.dummy		= tris[prim].dummy;
; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 319  : 			R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 320  : 			R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 324  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:
	movaps	xmm11, XMMWORD PTR [rsp+96]
$LN4@prim:

; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$ray_collider@$00$0A@$0A@$0A@@@QEAAXK@Z ENDP	; ray_collider<1,0,0,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,0,0,0>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,0,0,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,0,0,0>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$0A@$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,0,0,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z
_TEXT	SEGMENT
tv1031 = 224
this$ = 224
tv1026 = 232
prim$ = 232
tv1032 = 240
tv1029 = 248
?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z PROC	; ray_collider<1,0,0,1>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	rax, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-88], xmm9
	movaps	xmm9, xmm8
	movaps	XMMWORD PTR [rax-104], xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movss	xmm10, DWORD PTR [rbx+64]
	movaps	XMMWORD PTR [rax-120], xmm11

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm11, DWORD PTR [rbx+72]
	movaps	XMMWORD PTR [rsp+80], xmm12
	movaps	xmm0, xmm11
	movaps	XMMWORD PTR [rsp+64], xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	movaps	XMMWORD PTR [rsp+32], xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm15, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 280  : 	{

	mov	esi, edx

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm7, DWORD PTR [r10+r9*4+4]
	movss	xmm6, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm12, DWORD PTR [r10+rdx*4]
	movss	xmm13, DWORD PTR [r10+rdx*4+4]
	subss	xmm12, xmm6
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm13, xmm7
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm1, DWORD PTR [r10+rcx*4+8]
	subss	xmm1, DWORD PTR [r10+r9*4+8]
	movss	xmm2, DWORD PTR [r10+rcx*4]
	movss	xmm3, DWORD PTR [r10+rcx*4+4]
	subss	xmm2, xmm6
	subss	xmm3, xmm7

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm9, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm15, xmm2
	mulss	xmm0, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1029[rsp], xmm1
	movss	DWORD PTR tv1032[rsp], xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	subss	xmm9, xmm0

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1031[rsp], xmm3

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm0, xmm10
	mulss	xmm0, xmm1

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm10
	mulss	xmm1, xmm3
	subss	xmm15, xmm0
	movaps	xmm0, xmm8
	mulss	xmm0, xmm2
	subss	xmm1, xmm0
	movaps	xmm2, xmm15
	mulss	xmm2, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm9
	mulss	xmm0, xmm12

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv1026[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm14
	addss	xmm2, xmm0
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN61@prim
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN8@prim
$LN61@prim:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+36]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm5, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm3, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movaps	xmm4, xmm5
	divss	xmm4, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rbx+32]
	movaps	xmm7, xmm3
	subss	xmm2, xmm6
	mulss	xmm7, xmm15
	movss	xmm6, DWORD PTR [rbx+40]
	subss	xmm6, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm9
	xorps	xmm9, xmm9
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR tv1026[rsp]
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm7, xmm4

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm7
	ja	$LN8@prim
	comiss	xmm7, xmm5
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm13
	mulss	xmm1, xmm14
	mulss	xmm6, xmm12
	subss	xmm1, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm12
	movaps	xmm0, xmm2
	mulss	xmm2, xmm13
	mulss	xmm0, xmm14
	subss	xmm2, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm10, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm6, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm11, xmm2
	mulss	xmm8, xmm6
	addss	xmm8, xmm10
	addss	xmm8, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm8, xmm4

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm8
	ja	$LN8@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm5
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm6, DWORD PTR tv1031[rsp]
	mulss	xmm1, DWORD PTR tv1032[rsp]
	mulss	xmm2, DWORD PTR tv1029[rsp]
	addss	xmm6, xmm1
	addss	xmm6, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm6, xmm4

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm9, xmm6
	jae	$LN8@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN8@prim
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	mov	r8, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+24]
	sub	rax, r8
	sar	rax, 3
	imul	rax, rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 287  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN7@prim

; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{

	movss	xmm0, DWORD PTR [r8+44]
	comiss	xmm0, xmm6
	jbe	$LN8@prim

; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;

	movss	DWORD PTR [r8+44], xmm6

; 293  : 					R.u			= u;

	movss	DWORD PTR [r8+48], xmm7

; 294  : 					R.v			= v;

	movss	DWORD PTR [r8+52], xmm8
	mov	DWORD PTR [r8+40], esi

; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 298  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r8+36], ecx

; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {

	jmp	$LN62@prim
$LN7@prim:

; 303  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 306  : 				R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 307  : 				R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 311  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:

; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();
; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;
; 319  : 			R.u			= u;
; 320  : 			R.v			= v;
; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 324  : 			R.dummy		= tris[prim].dummy;
; 325  : 		}
; 326  : 	}

	movss	DWORD PTR [rbx+80], xmm6
	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN8@prim:
	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$0A@$0A@$00@@QEAAXK@Z ENDP	; ray_collider<1,0,0,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,0,0,1>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,0,0,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,0,0,1>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$0A@$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,0,0,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z
_TEXT	SEGMENT
tv1073 = 208
this$ = 208
tv1031 = 216
prim$ = 216
?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z PROC	; ray_collider<1,0,1,0>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	rax, rsp
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+64], xmm13
	movaps	XMMWORD PTR [rsp+48], xmm14
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	mov	esi, edx
	movaps	XMMWORD PTR [rsp+32], xmm15

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [r10+r9*4+4]
	movss	xmm9, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm1, DWORD PTR [r10+rdx*4]
	movss	xmm15, DWORD PTR [r10+rdx*4+8]
	subss	xmm1, xmm9
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm15, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r10+rcx*4+4]
	subss	xmm2, xmm10
	movss	xmm13, DWORD PTR [r10+rcx*4+8]
	subss	xmm6, xmm10
	movss	xmm12, DWORD PTR [r10+rcx*4]
	subss	xmm13, DWORD PTR [r10+r9*4+8]
	subss	xmm12, xmm9
	movss	DWORD PTR tv1073[rsp], xmm1

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm4, xmm6
	mulss	xmm0, DWORD PTR [rbx+72]
	mulss	xmm4, DWORD PTR [rbx+64]
	movaps	xmm14, xmm13
	mulss	xmm14, xmm8
	movaps	xmm7, xmm12
	mulss	xmm7, DWORD PTR [rbx+72]
	subss	xmm14, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rbx+64]
	subss	xmm7, xmm0
	movaps	xmm0, xmm12
	mulss	xmm0, xmm8
	subss	xmm4, xmm0
	movaps	xmm3, xmm7
	mulss	xmm3, xmm2

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm14
	mulss	xmm0, xmm1
	movaps	xmm1, xmm15
	mulss	xmm1, xmm4
	addss	xmm3, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv1031[rsp], xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm3, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN59@prim
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm3
	ja	$LN4@prim
$LN59@prim:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+32]
	subss	xmm5, xmm9
	movaps	XMMWORD PTR [rsp+96], xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm11, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+36]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movaps	xmm4, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm9, xmm10
	movss	xmm10, DWORD PTR [rbx+40]
	subss	xmm10, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm14, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm4, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm10
	mulss	xmm0, DWORD PTR tv1031[rsp]
	addss	xmm7, xmm14
	xorps	xmm14, xmm14
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm7, xmm4

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm14, xmm7
	ja	$LN62@prim
	comiss	xmm7, xmm11
	ja	$LN62@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm1, xmm15
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm15, xmm5
	mulss	xmm2, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm5, DWORD PTR [rbx+72]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm1, xmm9
	subss	xmm1, xmm0
	movss	xmm0, DWORD PTR tv1073[rsp]
	movaps	xmm3, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, xmm9
	mulss	xmm3, xmm10
	subss	xmm2, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm0, DWORD PTR [rbx+64]
	mulss	xmm0, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm3, xmm15

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm5, xmm2
	mulss	xmm8, xmm3
	addss	xmm8, xmm0
	addss	xmm8, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm8, xmm4

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm14, xmm8
	ja	$LN62@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm11
	ja	$LN62@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm6, xmm3
	mulss	xmm12, xmm1
	mulss	xmm13, xmm2
	addss	xmm6, xmm12
	addss	xmm6, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm6, xmm4

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm14, xmm6
	jae	$LN62@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN62@prim

; 284  : 		
; 285  : 		if (bNearest)	
; 286  : 		{
; 287  : 			if (dest->r_count())	
; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{
; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;
; 293  : 					R.u			= u;
; 294  : 					R.v			= v;
; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 298  : 					R.dummy		= tris[prim].dummy;
; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {
; 303  : 				RESULT& R	= dest->r_add();
; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;
; 306  : 				R.u			= u;
; 307  : 				R.v			= v;
; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 311  : 				R.dummy		= tris[prim].dummy;
; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 319  : 			R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 320  : 			R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 324  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:
	movaps	xmm11, XMMWORD PTR [rsp+96]
$LN4@prim:

; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+32]
	mov	rsi, QWORD PTR [r11+40]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$ray_collider@$00$0A@$00$0A@@@QEAAXK@Z ENDP	; ray_collider<1,0,1,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,0,1,0>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,0,1,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,0,1,0>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$0A@$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,0,1,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z
_TEXT	SEGMENT
tv1031 = 224
this$ = 224
tv1026 = 232
prim$ = 232
tv1032 = 240
tv1029 = 248
?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z PROC	; ray_collider<1,0,1,1>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	rax, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-40], xmm6
	movaps	XMMWORD PTR [rax-56], xmm7
	movaps	XMMWORD PTR [rax-72], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-88], xmm9
	movaps	xmm9, xmm8
	movaps	XMMWORD PTR [rax-104], xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movss	xmm10, DWORD PTR [rbx+64]
	movaps	XMMWORD PTR [rax-120], xmm11

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm11, DWORD PTR [rbx+72]
	movaps	XMMWORD PTR [rsp+80], xmm12
	movaps	xmm0, xmm11
	movaps	XMMWORD PTR [rsp+64], xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	movaps	XMMWORD PTR [rsp+32], xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm15, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 280  : 	{

	mov	esi, edx

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm7, DWORD PTR [r10+r9*4+4]
	movss	xmm6, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm12, DWORD PTR [r10+rdx*4]
	movss	xmm13, DWORD PTR [r10+rdx*4+4]
	subss	xmm12, xmm6
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm13, xmm7
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm1, DWORD PTR [r10+rcx*4+8]
	subss	xmm1, DWORD PTR [r10+r9*4+8]
	movss	xmm2, DWORD PTR [r10+rcx*4]
	movss	xmm3, DWORD PTR [r10+rcx*4+4]
	subss	xmm2, xmm6
	subss	xmm3, xmm7

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm9, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm15, xmm2
	mulss	xmm0, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1029[rsp], xmm1
	movss	DWORD PTR tv1032[rsp], xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	subss	xmm9, xmm0

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1031[rsp], xmm3

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm0, xmm10
	mulss	xmm0, xmm1

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm10
	mulss	xmm1, xmm3
	subss	xmm15, xmm0
	movaps	xmm0, xmm8
	mulss	xmm0, xmm2
	subss	xmm1, xmm0
	movaps	xmm2, xmm15
	mulss	xmm2, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm9
	mulss	xmm0, xmm12

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv1026[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm14
	addss	xmm2, xmm0
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN61@prim
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN8@prim
$LN61@prim:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+36]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm5, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm3, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movaps	xmm4, xmm5
	divss	xmm4, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rbx+32]
	movaps	xmm7, xmm3
	subss	xmm2, xmm6
	mulss	xmm7, xmm15
	movss	xmm6, DWORD PTR [rbx+40]
	subss	xmm6, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm2
	mulss	xmm0, xmm9
	xorps	xmm9, xmm9
	movaps	xmm1, xmm6
	mulss	xmm1, DWORD PTR tv1026[rsp]
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm7, xmm4

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm7
	ja	$LN8@prim
	comiss	xmm7, xmm5
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6
	movaps	xmm1, xmm3
	mulss	xmm0, xmm13
	mulss	xmm1, xmm14
	mulss	xmm6, xmm12
	subss	xmm1, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm12
	movaps	xmm0, xmm2
	mulss	xmm2, xmm13
	mulss	xmm0, xmm14
	subss	xmm2, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm10, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm6, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm11, xmm2
	mulss	xmm8, xmm6
	addss	xmm8, xmm10
	addss	xmm8, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm8, xmm4

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm8
	ja	$LN8@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm5
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm6, DWORD PTR tv1031[rsp]
	mulss	xmm1, DWORD PTR tv1032[rsp]
	mulss	xmm2, DWORD PTR tv1029[rsp]
	addss	xmm6, xmm1
	addss	xmm6, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm6, xmm4

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm9, xmm6
	jae	$LN8@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN8@prim
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	mov	r8, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+24]
	sub	rax, r8
	sar	rax, 3
	imul	rax, rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 287  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN7@prim

; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{

	movss	xmm0, DWORD PTR [r8+44]
	comiss	xmm0, xmm6
	jbe	$LN8@prim

; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;

	movss	DWORD PTR [r8+44], xmm6

; 293  : 					R.u			= u;

	movss	DWORD PTR [r8+48], xmm7

; 294  : 					R.v			= v;

	movss	DWORD PTR [r8+52], xmm8
	mov	DWORD PTR [r8+40], esi

; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 298  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r8+36], ecx

; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {

	jmp	$LN62@prim
$LN7@prim:

; 303  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 306  : 				R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 307  : 				R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 311  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:

; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();
; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;
; 319  : 			R.u			= u;
; 320  : 			R.v			= v;
; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 324  : 			R.dummy		= tris[prim].dummy;
; 325  : 		}
; 326  : 	}

	movss	DWORD PTR [rbx+80], xmm6
	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN8@prim:
	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$0A@$00$00@@QEAAXK@Z ENDP	; ray_collider<1,0,1,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,0,1,1>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,0,1,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,0,1,1>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$0A@$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,0,1,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z
_TEXT	SEGMENT
this$ = 208
prim$ = 216
?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z PROC	; ray_collider<1,1,0,0>::_prim, COMDAT

; 280  : 	{

$LN61:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+64], xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	mov	esi, edx
	movaps	XMMWORD PTR [rsp+32], xmm15

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [r10+r9*4+4]
	movss	xmm9, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm15, DWORD PTR [r10+rdx*4]
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm15, xmm9
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm2, xmm10
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r10+rcx*4+4]
	movss	xmm12, DWORD PTR [r10+rcx*4+8]
	subss	xmm6, xmm10
	movss	xmm11, DWORD PTR [r10+rcx*4]
	subss	xmm12, DWORD PTR [r10+r9*4+8]
	subss	xmm11, xmm9

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm13, xmm6
	mulss	xmm0, DWORD PTR [rbx+72]
	mulss	xmm13, DWORD PTR [rbx+64]
	movaps	xmm3, xmm12
	mulss	xmm3, xmm8
	movaps	xmm7, xmm11
	mulss	xmm7, DWORD PTR [rbx+72]
	subss	xmm3, xmm0
	movaps	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+64]
	subss	xmm7, xmm0
	movaps	xmm0, xmm11
	mulss	xmm0, xmm8
	subss	xmm13, xmm0
	movaps	xmm4, xmm7

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm2

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm15
	movaps	xmm1, xmm13
	mulss	xmm1, xmm14
	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm4
	ja	$LN4@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+32]
	subss	xmm5, xmm9
	movss	xmm9, DWORD PTR [rbx+36]
	subss	xmm9, xmm10
	movss	xmm10, DWORD PTR [rbx+40]
	subss	xmm10, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm3, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm13, xmm10
	addss	xmm7, xmm3
	addss	xmm7, xmm13
	xorps	xmm13, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm13, xmm7
	ja	$LN4@prim
	comiss	xmm7, xmm4
	ja	$LN4@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm1, xmm14
	mulss	xmm0, xmm10
	movaps	xmm3, xmm15

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm14, xmm5
	mulss	xmm2, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm5, DWORD PTR [rbx+72]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm1, xmm9
	mulss	xmm3, xmm10
	subss	xmm1, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm15, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm0, DWORD PTR [rbx+64]

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm3, xmm14

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	subss	xmm2, xmm15

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm1
	mulss	xmm8, xmm3
	mulss	xmm5, xmm2
	addss	xmm8, xmm0
	addss	xmm8, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm13, xmm8
	ja	$LN4@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm4
	ja	$LN4@prim

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm4
	mulss	xmm6, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm11, xmm1
	mulss	xmm12, xmm2
	addss	xmm6, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm7, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm8, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm12
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 260  : 			range	*= inv_det;

	mulss	xmm6, xmm0

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm13, xmm6
	jae	$LN4@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN4@prim

; 284  : 		
; 285  : 		if (bNearest)	
; 286  : 		{
; 287  : 			if (dest->r_count())	
; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{
; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;
; 293  : 					R.u			= u;
; 294  : 					R.v			= v;
; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 298  : 					R.dummy		= tris[prim].dummy;
; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {
; 303  : 				RESULT& R	= dest->r_add();
; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;
; 306  : 				R.u			= u;
; 307  : 				R.v			= v;
; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 311  : 				R.dummy		= tris[prim].dummy;
; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 319  : 			R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 320  : 			R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 324  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN4@prim:

; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$ray_collider@$00$00$0A@$0A@@@QEAAXK@Z ENDP	; ray_collider<1,1,0,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,1,0,0>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,1,0,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,1,0,0>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$00$0A@$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,1,0,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z
_TEXT	SEGMENT
tv1031 = 224
this$ = 224
tv1030 = 232
prim$ = 232
tv1029 = 240
?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z PROC	; ray_collider<1,1,0,1>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	r11, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [r11-40], xmm6
	movaps	XMMWORD PTR [r11-56], xmm7
	movaps	XMMWORD PTR [r11-72], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [r11-104], xmm10
	movaps	xmm6, xmm8
	movaps	XMMWORD PTR [r11-120], xmm11
	movaps	XMMWORD PTR [rsp+80], xmm12

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movss	xmm12, DWORD PTR [rbx+64]
	movaps	XMMWORD PTR [rsp+64], xmm13

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm13, DWORD PTR [rbx+72]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	movaps	XMMWORD PTR [rsp+32], xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm10, xmm13

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm15, xmm12
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 280  : 	{

	mov	esi, edx

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm7, DWORD PTR [r10+r9*4+4]
	movss	xmm5, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm11, DWORD PTR [r10+rdx*4]
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm11, xmm5
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm2, xmm7
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r10+rcx*4+4]
	movss	xmm1, DWORD PTR [r10+rcx*4]
	subss	xmm3, xmm7
	movss	xmm4, DWORD PTR [r10+rcx*4+8]
	subss	xmm1, xmm5
	subss	xmm4, DWORD PTR [r10+r9*4+8]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm0, xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm15, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1030[rsp], xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm3, xmm2
	mulss	xmm10, xmm1

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1031[rsp], xmm1

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm6, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1029[rsp], xmm4

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	subss	xmm6, xmm0

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm0, xmm12
	mulss	xmm0, xmm4
	subss	xmm10, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm8
	mulss	xmm0, xmm1
	subss	xmm15, xmm0
	mulss	xmm3, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm11
	mulss	xmm0, xmm6
	movaps	xmm1, xmm15
	mulss	xmm1, xmm14
	addss	xmm3, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm3
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rbx+32]
	subss	xmm4, xmm5
	movaps	XMMWORD PTR [r11-88], xmm9
	movss	xmm5, DWORD PTR [rbx+36]
	movss	xmm9, DWORD PTR [rbx+40]
	subss	xmm5, xmm7
	subss	xmm9, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm9

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm10
	xorps	xmm10, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm15
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm10, xmm7
	ja	$LN61@prim
	comiss	xmm7, xmm3
	ja	$LN61@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm6, xmm11
	mulss	xmm0, xmm9
	movaps	xmm1, xmm5
	mulss	xmm1, xmm14
	mulss	xmm6, xmm9
	subss	xmm1, xmm0

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm2, xmm4
	movaps	xmm0, xmm4

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm11, xmm5
	mulss	xmm0, xmm14
	subss	xmm2, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm12, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm6, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm13, xmm2
	mulss	xmm8, xmm6
	addss	xmm8, xmm12
	addss	xmm8, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm10, xmm8
	ja	$LN61@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm3
	ja	$LN61@prim

; 259  : 			inv_det = 1.0f / det;

	mulss	xmm6, DWORD PTR tv1030[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, DWORD PTR tv1031[rsp]
	mulss	xmm2, DWORD PTR tv1029[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 259  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm7, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm8, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 260  : 			range	*= inv_det;

	mulss	xmm6, xmm0

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm10, xmm6
	jae	$LN61@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN61@prim
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	mov	r8, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+24]
	sub	rax, r8
	sar	rax, 3
	imul	rax, rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 287  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN7@prim

; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{

	movss	xmm0, DWORD PTR [r8+44]
	comiss	xmm0, xmm6
	jbe	$LN61@prim

; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;

	movss	DWORD PTR [r8+44], xmm6

; 293  : 					R.u			= u;

	movss	DWORD PTR [r8+48], xmm7

; 294  : 					R.v			= v;

	movss	DWORD PTR [r8+52], xmm8
	mov	DWORD PTR [r8+40], esi

; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 298  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r8+36], ecx

; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {

	jmp	$LN62@prim
$LN7@prim:

; 303  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 306  : 				R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 307  : 				R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 311  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:

; 312  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 313  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN61@prim:
	movaps	xmm9, XMMWORD PTR [rsp+128]
$LN8@prim:

; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();
; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;
; 319  : 			R.u			= u;
; 320  : 			R.v			= v;
; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 324  : 			R.dummy		= tris[prim].dummy;
; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$00$0A@$00@@QEAAXK@Z ENDP	; ray_collider<1,1,0,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,1,0,1>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,1,0,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,1,0,1>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$00$0A@$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,1,0,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z
_TEXT	SEGMENT
this$ = 208
prim$ = 216
?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z PROC	; ray_collider<1,1,1,0>::_prim, COMDAT

; 280  : 	{

$LN61:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+16], rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	movaps	XMMWORD PTR [rsp+64], xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	mov	esi, edx
	movaps	XMMWORD PTR [rsp+32], xmm15

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [r10+r9*4+4]
	movss	xmm9, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm15, DWORD PTR [r10+rdx*4]
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm15, xmm9
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm2, xmm10
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm6, DWORD PTR [r10+rcx*4+4]
	movss	xmm12, DWORD PTR [r10+rcx*4+8]
	subss	xmm6, xmm10
	movss	xmm11, DWORD PTR [r10+rcx*4]
	subss	xmm12, DWORD PTR [r10+r9*4+8]
	subss	xmm11, xmm9

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm13, xmm6
	mulss	xmm0, DWORD PTR [rbx+72]
	mulss	xmm13, DWORD PTR [rbx+64]
	movaps	xmm3, xmm12
	mulss	xmm3, xmm8
	movaps	xmm7, xmm11
	mulss	xmm7, DWORD PTR [rbx+72]
	subss	xmm3, xmm0
	movaps	xmm0, xmm12
	mulss	xmm0, DWORD PTR [rbx+64]
	subss	xmm7, xmm0
	movaps	xmm0, xmm11
	mulss	xmm0, xmm8
	subss	xmm13, xmm0
	movaps	xmm4, xmm7

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm2

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm15
	movaps	xmm1, xmm13
	mulss	xmm1, xmm14
	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm4
	ja	$LN4@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+32]
	subss	xmm5, xmm9
	movss	xmm9, DWORD PTR [rbx+36]
	subss	xmm9, xmm10
	movss	xmm10, DWORD PTR [rbx+40]
	subss	xmm10, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm3, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm13, xmm10
	addss	xmm7, xmm3
	addss	xmm7, xmm13
	xorps	xmm13, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm13, xmm7
	ja	$LN4@prim
	comiss	xmm7, xmm4
	ja	$LN4@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm1, xmm14
	mulss	xmm0, xmm10
	movaps	xmm3, xmm15

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm14, xmm5
	mulss	xmm2, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm5, DWORD PTR [rbx+72]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm1, xmm9
	mulss	xmm3, xmm10
	subss	xmm1, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm15, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movss	xmm0, DWORD PTR [rbx+64]

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm3, xmm14

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	subss	xmm2, xmm15

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm1
	mulss	xmm8, xmm3
	mulss	xmm5, xmm2
	addss	xmm8, xmm0
	addss	xmm8, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm13, xmm8
	ja	$LN4@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm4
	ja	$LN4@prim

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000
	divss	xmm0, xmm4
	mulss	xmm6, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm11, xmm1
	mulss	xmm12, xmm2
	addss	xmm6, xmm11
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm7, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm8, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm12
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 260  : 			range	*= inv_det;

	mulss	xmm6, xmm0

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm13, xmm6
	jae	$LN4@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN4@prim

; 284  : 		
; 285  : 		if (bNearest)	
; 286  : 		{
; 287  : 			if (dest->r_count())	
; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{
; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;
; 293  : 					R.u			= u;
; 294  : 					R.v			= v;
; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];
; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];
; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];
; 298  : 					R.dummy		= tris[prim].dummy;
; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {
; 303  : 				RESULT& R	= dest->r_add();
; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;
; 306  : 				R.u			= u;
; 307  : 				R.v			= v;
; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];
; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];
; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];
; 311  : 				R.dummy		= tris[prim].dummy;
; 312  : 				rRange		= r;
; 313  : 				rRange2		= r*r;
; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();

	mov	rcx, QWORD PTR [rbx]
	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 319  : 			R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 320  : 			R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 324  : 			R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN4@prim:

; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	mov	rbx, QWORD PTR [r11+16]
	mov	rsi, QWORD PTR [r11+24]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	ret	0
?_prim@?$ray_collider@$00$00$00$0A@@@QEAAXK@Z ENDP	; ray_collider<1,1,1,0>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,1,1,0>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,1,1,0>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,1,1,0>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$00$00$0A@@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,1,1,0>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z
_TEXT	SEGMENT
tv1031 = 224
this$ = 224
tv1030 = 232
prim$ = 232
tv1029 = 240
?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z PROC	; ray_collider<1,1,1,1>::_prim, COMDAT

; 280  : 	{

$LN64:
	mov	r11, rsp
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 192				; 000000c0H

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	r10, QWORD PTR [rcx+16]

; 280  : 	{

	mov	rbx, rcx

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	r8, QWORD PTR [rcx+8]
	movaps	XMMWORD PTR [r11-40], xmm6
	movaps	XMMWORD PTR [r11-56], xmm7
	movaps	XMMWORD PTR [r11-72], xmm8
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm8, DWORD PTR [rbx+68]
	movaps	XMMWORD PTR [r11-104], xmm10
	movaps	xmm6, xmm8
	movaps	XMMWORD PTR [r11-120], xmm11
	movaps	XMMWORD PTR [rsp+80], xmm12

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movss	xmm12, DWORD PTR [rbx+64]
	movaps	XMMWORD PTR [rsp+64], xmm13

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movss	xmm13, DWORD PTR [rbx+72]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	mov	edi, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 282  : 		if (!_tri(tris[prim].verts, u, v, r))	return;

	add	rdi, rdi
	movaps	XMMWORD PTR [rsp+48], xmm14
	movaps	XMMWORD PTR [rsp+32], xmm15
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm10, xmm13

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm15, xmm12
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 280  : 	{

	mov	esi, edx

; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	eax, DWORD PTR [r8+rdi*8]
	lea	r9, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [r8+rdi*8+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm7, DWORD PTR [r10+r9*4+4]
	movss	xmm5, DWORD PTR [r10+r9*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	rdx, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [r8+rdi*8+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm11, DWORD PTR [r10+rdx*4]
	movss	xmm2, DWORD PTR [r10+rdx*4+4]
	subss	xmm11, xmm5
	movss	xmm14, DWORD PTR [r10+rdx*4+8]
	subss	xmm2, xmm7
	subss	xmm14, DWORD PTR [r10+r9*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rcx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r10+rcx*4+4]
	movss	xmm1, DWORD PTR [r10+rcx*4]
	subss	xmm3, xmm7
	movss	xmm4, DWORD PTR [r10+rcx*4+8]
	subss	xmm1, xmm5
	subss	xmm4, DWORD PTR [r10+r9*4+8]

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm0, xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm15, xmm3

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1030[rsp], xmm3

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm3, xmm2
	mulss	xmm10, xmm1

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1031[rsp], xmm1

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	mulss	xmm6, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	DWORD PTR tv1029[rsp], xmm4

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	subss	xmm6, xmm0

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	movaps	xmm0, xmm12
	mulss	xmm0, xmm4
	subss	xmm10, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm8
	mulss	xmm0, xmm1
	subss	xmm15, xmm0
	mulss	xmm3, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm11
	mulss	xmm0, xmm6
	movaps	xmm1, xmm15
	mulss	xmm1, xmm14
	addss	xmm3, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm3
	ja	$LN8@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rbx+32]
	subss	xmm4, xmm5
	movaps	XMMWORD PTR [r11-88], xmm9
	movss	xmm5, DWORD PTR [rbx+36]
	movss	xmm9, DWORD PTR [rbx+40]
	subss	xmm5, xmm7
	subss	xmm9, DWORD PTR [r10+r9*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4
	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm5

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm9

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm7, xmm10
	xorps	xmm10, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm15
	addss	xmm7, xmm0
	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm10, xmm7
	ja	$LN61@prim
	comiss	xmm7, xmm3
	ja	$LN61@prim
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm2
	movaps	xmm6, xmm11
	mulss	xmm0, xmm9
	movaps	xmm1, xmm5
	mulss	xmm1, xmm14
	mulss	xmm6, xmm9
	subss	xmm1, xmm0

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	mulss	xmm2, xmm4
	movaps	xmm0, xmm4

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm11, xmm5
	mulss	xmm0, xmm14
	subss	xmm2, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm12, xmm1

; 283  :         y = v1.z * v2.x - v1.x * v2.z;

	subss	xmm6, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm13, xmm2
	mulss	xmm8, xmm6
	addss	xmm8, xmm12
	addss	xmm8, xmm13
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm10, xmm8
	ja	$LN61@prim
	movaps	xmm0, xmm7
	addss	xmm0, xmm8
	comiss	xmm0, xmm3
	ja	$LN61@prim

; 259  : 			inv_det = 1.0f / det;

	mulss	xmm6, DWORD PTR tv1030[rsp]
	movss	xmm0, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, DWORD PTR tv1031[rsp]
	mulss	xmm2, DWORD PTR tv1029[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 259  : 			inv_det = 1.0f / det;

	divss	xmm0, xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm7, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm8, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm6, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 260  : 			range	*= inv_det;

	mulss	xmm6, xmm0

; 283  : 		if (r<=0 || r>rRange)					return;

	comiss	xmm10, xmm6
	jae	$LN61@prim
	comiss	xmm6, DWORD PTR [rbx+80]
	ja	$LN61@prim
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.26.28801\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

	mov	rcx, QWORD PTR [rbx]

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

	mov	rdx, 7905747460161236407		; 6db6db6db6db6db7H
	mov	r8, QWORD PTR [rcx+16]
	mov	rax, QWORD PTR [rcx+24]
	sub	rax, r8
	sar	rax, 3
	imul	rax, rdx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 287  : 			if (dest->r_count())	

	test	eax, eax
	je	$LN7@prim

; 288  : 			{
; 289  : 				RESULT& R = *dest->r_begin();
; 290  : 				if (r<R.range)	{

	movss	xmm0, DWORD PTR [r8+44]
	comiss	xmm0, xmm6
	jbe	$LN61@prim

; 291  : 					R.id		= prim;
; 292  : 					R.range		= r;

	movss	DWORD PTR [r8+44], xmm6

; 293  : 					R.u			= u;

	movss	DWORD PTR [r8+48], xmm7

; 294  : 					R.v			= v;

	movss	DWORD PTR [r8+52], xmm8
	mov	DWORD PTR [r8+40], esi

; 295  : 					R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+8], eax

; 296  : 					R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+20], eax

; 297  : 					R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r8+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r8+32], eax

; 298  : 					R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r8+36], ecx

; 299  : 					rRange		= r;
; 300  : 					rRange2		= r*r;
; 301  : 				}
; 302  : 			} else {

	jmp	$LN62@prim
$LN7@prim:

; 303  : 				RESULT& R	= dest->r_add();

	call	?r_add@COLLIDER@CDB@@QEAAAEAURESULT@2@XZ ; CDB::COLLIDER::r_add
	mov	r9, rax

; 304  : 				R.id		= prim;
; 305  : 				R.range		= r;

	movss	DWORD PTR [rax+44], xmm6

; 306  : 				R.u			= u;

	movss	DWORD PTR [rax+48], xmm7

; 307  : 				R.v			= v;

	movss	DWORD PTR [rax+52], xmm8
	mov	DWORD PTR [rax+40], esi

; 308  : 				R.verts	[0]	= verts[tris[prim].verts[0]];

	mov	rcx, QWORD PTR [rbx+8]
	mov	edx, DWORD PTR [rcx+rdi*8]
	mov	rcx, QWORD PTR [rbx+16]
	lea	r8, QWORD PTR [rdx+rdx*2]
	movsd	xmm0, QWORD PTR [rcx+r8*4]
	movsd	QWORD PTR [rax], xmm0
	mov	ecx, DWORD PTR [rcx+r8*4+8]
	mov	DWORD PTR [rax+8], ecx

; 309  : 				R.verts	[1]	= verts[tris[prim].verts[1]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+4]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+12], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+20], eax

; 310  : 				R.verts	[2]	= verts[tris[prim].verts[2]];

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+8]
	mov	rax, QWORD PTR [rbx+16]
	lea	rdx, QWORD PTR [rcx+rcx*2]
	movsd	xmm0, QWORD PTR [rax+rdx*4]
	movsd	QWORD PTR [r9+24], xmm0
	mov	eax, DWORD PTR [rax+rdx*4+8]
	mov	DWORD PTR [r9+32], eax

; 311  : 				R.dummy		= tris[prim].dummy;

	mov	rax, QWORD PTR [rbx+8]
	mov	ecx, DWORD PTR [rax+rdi*8+12]
	mov	DWORD PTR [r9+36], ecx
$LN62@prim:

; 312  : 				rRange		= r;

	movss	DWORD PTR [rbx+80], xmm6

; 313  : 				rRange2		= r*r;

	mulss	xmm6, xmm6
	movss	DWORD PTR [rbx+84], xmm6
$LN61@prim:
	movaps	xmm9, XMMWORD PTR [rsp+128]
$LN8@prim:

; 314  : 			}
; 315  : 		} else {
; 316  : 			RESULT& R	= dest->r_add();
; 317  : 			R.id		= prim;
; 318  : 			R.range		= r;
; 319  : 			R.u			= u;
; 320  : 			R.v			= v;
; 321  : 			R.verts	[0]	= verts[tris[prim].verts[0]];
; 322  : 			R.verts	[1]	= verts[tris[prim].verts[1]];
; 323  : 			R.verts	[2]	= verts[tris[prim].verts[2]];
; 324  : 			R.dummy		= tris[prim].dummy;
; 325  : 		}
; 326  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+48]
	lea	r11, QWORD PTR [rsp+192]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp+32]
	mov	rsp, r11
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?_prim@?$ray_collider@$00$00$00$00@@QEAAXK@Z ENDP	; ray_collider<1,1,1,1>::_prim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_sse@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z
_TEXT	SEGMENT
this$ = 8
bCenter$ = 16
bExtents$ = 24
dist$ = 32
?_box_sse@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z PROC ; ray_collider<1,1,1,1>::_box_sse, COMDAT

; 218  : 		aabb_t		box;
; 219  : 	/*
; 220  : 		box.min.sub (bCenter,bExtents);	box.min.pad = 0;
; 221  : 		box.max.add	(bCenter,bExtents); box.max.pad = 0;
; 222  : 	*/
; 223  : 		__m128 CN = _mm_unpacklo_ps( _mm_load_ss( (float*) &bCenter.x ) , _mm_load_ss( (float*) &bCenter.y ) );

	movsd	xmm2, QWORD PTR [rdx]

; 224  : 		CN = _mm_movelh_ps( CN , _mm_load_ss( (float*) &bCenter.z ) );

	movss	xmm0, DWORD PTR [rdx+8]

; 225  : 		__m128 EX = _mm_unpacklo_ps( _mm_load_ss( (float*) &bExtents.x ) , _mm_load_ss( (float*) &bExtents.y ) );

	movsd	xmm3, QWORD PTR [r8]
	movlhps	xmm2, xmm0

; 226  : 		EX = _mm_movelh_ps( EX , _mm_load_ss( (float*) &bExtents.z ) );

	movss	xmm0, DWORD PTR [r8+8]

; 227  : 
; 228  : 		_mm_store_ps( (float*) &box.min , _mm_sub_ps( CN , EX ) );

	movaps	xmm4, xmm2
	movlhps	xmm3, xmm0
	subps	xmm4, xmm3

; 229  : 		_mm_store_ps( (float*) &box.max , _mm_add_ps( CN , EX ) );

	addps	xmm3, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 137  : 	const __m128 l1 = mulps(subps(box_min, pos), inv_dir);

	subps	xmm4, XMMWORD PTR [rcx+32]

; 138  : 	const __m128 l2 = mulps(subps(box_max, pos), inv_dir);

	subps	xmm3, XMMWORD PTR [rcx+32]
	mulps	xmm4, XMMWORD PTR [rcx+48]
	mulps	xmm3, XMMWORD PTR [rcx+48]

; 139  : 
; 140  : 	// the order we use for those min/max is vital to filter out
; 141  : 	// NaNs that happens when an inv_dir is +/- inf and
; 142  : 	// (box_min - pos) is 0. inf * 0 = NaN
; 143  : 	const __m128 filtered_l1a = minps(l1, plus_inf);

	movaps	xmm2, xmm4
	minps	xmm2, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 144  : 	const __m128 filtered_l2a = minps(l2, plus_inf);
; 145  : 
; 146  : 	const __m128 filtered_l1b = maxps(l1, minus_inf);

	maxps	xmm4, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB
	movaps	xmm1, xmm3
	minps	xmm1, XMMWORD PTR ?ps_cst_plus_inf@@3QBMB

; 147  : 	const __m128 filtered_l2b = maxps(l2, minus_inf);

	maxps	xmm3, XMMWORD PTR ?ps_cst_minus_inf@@3QBMB

; 148  : 
; 149  : 	// now that we're back on our feet, test those slabs.
; 150  : 	__m128 lmax = maxps(filtered_l1a, filtered_l2a);

	maxps	xmm2, xmm1

; 151  : 	__m128 lmin = minps(filtered_l1b, filtered_l2b);

	minps	xmm4, xmm3

; 152  : 
; 153  : 	// unfold back. try to hide the latency of the shufps & co.
; 154  : 	const __m128 lmax0 = rotatelps(lmax);

	movaps	xmm0, xmm2
	shufps	xmm0, xmm2, 57				; 00000039H

; 155  : 	const __m128 lmin0 = rotatelps(lmin);

	movaps	xmm1, xmm4

; 156  : 	lmax = minss(lmax, lmax0);

	minss	xmm2, xmm0
	shufps	xmm1, xmm4, 57				; 00000039H

; 157  : 	lmin = maxss(lmin, lmin0);

	maxss	xmm4, xmm1

; 158  : 
; 159  : 	const __m128 lmax1 = muxhps(lmax,lmax);

	movaps	xmm0, xmm2
	movhlps	xmm0, xmm2

; 160  : 	const __m128 lmin1 = muxhps(lmin,lmin);
; 161  : 	lmax = minss(lmax, lmax1);

	minss	xmm2, xmm0
	movaps	xmm0, xmm4
	movhlps	xmm0, xmm4

; 162  : 	lmin = maxss(lmin, lmin1);

	maxss	xmm4, xmm0
	xorps	xmm0, xmm0

; 163  : 
; 164  : 	const BOOL ret = _mm_comige_ss(lmax, _mm_setzero_ps()) & _mm_comige_ss(lmax,lmin);

	comiss	xmm2, xmm4

; 165  : 
; 166  : 	storess		(lmin, &dist);

	movss	DWORD PTR [r9], xmm4
	setae	al
	comiss	xmm2, xmm0
	movzx	eax, al
	setae	cl
	movzx	edx, cl
	and	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 232  : 	}

	ret	0
?_box_sse@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAM@Z ENDP ; ray_collider<1,1,1,1>::_box_sse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z
_TEXT	SEGMENT
MaxT$1 = 0
this$ = 96
bCenter$ = 104
bExtents$ = 112
coord$ = 120
?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z PROC ; ray_collider<1,1,1,1>::_box_fpu, COMDAT

; 209  : 	{

$LN264:
	sub	rsp, 88					; 00000058H
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rdx]
	movss	xmm0, DWORD PTR [rdx+8]
	movss	xmm1, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	edx, 1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [r8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 36   : 	BOOL Inside			= TRUE;

	mov	eax, edx
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [r8+8]
	movss	xmm5, DWORD PTR [r8+4]
	movaps	XMMWORD PTR [rsp+64], xmm6
	movaps	xmm6, xmm0
	movaps	XMMWORD PTR [rsp+48], xmm7
	subss	xmm6, xmm4
	movaps	XMMWORD PTR [rsp+32], xmm8

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm4, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	xmm0, DWORD PTR __real@bf800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm8, xmm2
	subss	xmm8, xmm3
	movaps	XMMWORD PTR [rsp+16], xmm9
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 39   : 	if(ray.pos[0] < min[0]) {

	movss	xmm9, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm3, xmm2

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+8], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm7, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp+4], xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 32   :     ICF SelfRef add(const Self& a, const Self& v) { x = a.x + v.x; y = a.y + v.y; z = a.z + v.z; return *this; };

	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\ISpatial_q_ray.cpp

; 35   : 	MaxT.x=MaxT.y=MaxT.z=-1.0f;

	movss	DWORD PTR MaxT$1[rsp], xmm0

; 39   : 	if(ray.pos[0] < min[0]) {

	comiss	xmm8, xmm9
	movaps	xmm1, xmm0
	movaps	xmm2, xmm0
	jbe	SHORT $LN8@box_fpu

; 40   : 		coord[0]	= min[0];
; 41   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm8

; 42   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (min[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm8

; 43   : 	} else if(ray.pos[0] > max[0]) {

	jmp	SHORT $LN259@box_fpu
$LN8@box_fpu:
	comiss	xmm9, xmm3
	jbe	SHORT $LN12@box_fpu

; 44   : 		coord[0]	= max[0];
; 45   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9], xmm3

; 46   : 		if(uf(ray.inv_dir[0]))	MaxT[0] = (max[0] - ray.pos[0]) * ray.inv_dir[0]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+48], eax
	je	SHORT $LN12@box_fpu
	movaps	xmm2, xmm3
$LN259@box_fpu:

; 47   : 	}
; 48   : 	if(ray.pos[1] < min[1]) {

	subss	xmm2, DWORD PTR [rcx+32]
	mulss	xmm2, DWORD PTR [rcx+48]
	movss	DWORD PTR MaxT$1[rsp], xmm2
$LN12@box_fpu:
	movss	xmm9, DWORD PTR [rcx+36]
	comiss	xmm7, xmm9
	jbe	SHORT $LN13@box_fpu

; 49   : 		coord[1]	= min[1];
; 50   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm7

; 51   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (min[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm7
	jmp	SHORT $LN260@box_fpu
$LN13@box_fpu:

; 52   : 	} else if(ray.pos[1] > max[1]) {

	comiss	xmm9, xmm5
	jbe	SHORT $LN17@box_fpu

; 53   : 		coord[1]	= max[1];
; 54   : 		Inside		= FALSE;

	xor	eax, eax
	movss	DWORD PTR [r9+4], xmm5

; 55   : 		if(uf(ray.inv_dir[1]))	MaxT[1] = (max[1] - ray.pos[1]) * ray.inv_dir[1]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+52], eax
	je	SHORT $LN17@box_fpu
	movaps	xmm1, xmm5
$LN260@box_fpu:

; 56   : 	}
; 57   : 	if(ray.pos[2] < min[2]) {

	subss	xmm1, DWORD PTR [rcx+36]
	mulss	xmm1, DWORD PTR [rcx+52]
	movss	DWORD PTR MaxT$1[rsp+4], xmm1
$LN17@box_fpu:
	movss	xmm9, DWORD PTR [rcx+40]
	comiss	xmm6, xmm9
	jbe	$LN18@box_fpu

; 58   : 		coord[2]	= min[2];

	movss	DWORD PTR [r9+8], xmm6

; 59   : 		Inside		= FALSE;
; 60   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (min[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	SHORT $LN23@box_fpu
	movaps	xmm0, xmm6
$LN261@box_fpu:

; 71   : 	}
; 72   : 
; 73   : 	// Get largest of the maxT's for final choice of intersection
; 74   : 	u32 WhichPlane = 0;
; 75   : 	if	(MaxT[1] > MaxT[0])				WhichPlane = 1;

	subss	xmm0, DWORD PTR [rcx+40]
	mulss	xmm0, DWORD PTR [rcx+56]
	movss	DWORD PTR MaxT$1[rsp+8], xmm0
$LN23@box_fpu:
	xor	r8d, r8d

; 76   : 	if	(MaxT[2] > MaxT[WhichPlane])	WhichPlane = 2;

	mov	r10d, 2
	comiss	xmm1, xmm2
	cmova	r8d, edx
	comiss	xmm0, DWORD PTR MaxT$1[rsp+r8*4]
	cmova	r8d, r10d

; 77   : 
; 78   : 	// Check final candidate actually inside box (if max < 0)
; 79   : 	if(uf(MaxT[WhichPlane])&0x80000000) return false;

	cmp	DWORD PTR MaxT$1[rsp+r8*4], 0
	jl	$LN37@box_fpu

; 80   : 
; 81   : 	if  (0==WhichPlane)	{	// 1 & 2

	test	r8d, r8d
	jne	SHORT $LN27@box_fpu

; 82   : 		coord[1] = ray.pos[1] + MaxT[0] * ray.fwd_dir[1];

	movaps	xmm3, xmm2
	mulss	xmm3, DWORD PTR [rcx+68]
	addss	xmm3, DWORD PTR [rcx+36]

; 83   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm3
	movss	DWORD PTR [r9+4], xmm3
	ja	$LN37@box_fpu
	comiss	xmm3, xmm5
	ja	$LN37@box_fpu

; 84   : 		coord[2] = ray.pos[2] + MaxT[0] * ray.fwd_dir[2];

	mulss	xmm2, DWORD PTR [rcx+72]
	addss	xmm2, DWORD PTR [rcx+40]

; 85   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm2
	movss	DWORD PTR [r9+8], xmm2
	ja	$LN37@box_fpu
	comiss	xmm2, xmm4
	jmp	$LN262@box_fpu
$LN18@box_fpu:

; 61   : 	} else if(ray.pos[2] > max[2]) {

	comiss	xmm9, xmm4
	jbe	SHORT $LN22@box_fpu

; 62   : 		coord[2]	= max[2];

	movss	DWORD PTR [r9+8], xmm4

; 63   : 		Inside		= FALSE;
; 64   : 		if(uf(ray.inv_dir[2]))	MaxT[2] = (max[2] - ray.pos[2]) * ray.inv_dir[2]; // Calculate T distances to candidate planes

	cmp	DWORD PTR [rcx+56], 0
	je	$LN23@box_fpu
	movaps	xmm0, xmm4

; 65   : 	}
; 66   : 
; 67   : 	// Ray ray.pos inside bounding box
; 68   : 	if(Inside)		{

	jmp	$LN261@box_fpu
$LN22@box_fpu:
	test	eax, eax
	je	$LN23@box_fpu

; 69   : 		coord		= ray.pos;

	movsd	xmm0, QWORD PTR [rcx+32]
	movsd	QWORD PTR [r9], xmm0
	mov	eax, DWORD PTR [rcx+40]
	mov	DWORD PTR [r9+8], eax

; 70   : 		return		true;

	jmp	SHORT $LN7@box_fpu
$LN27@box_fpu:

; 86   : 		return true;
; 87   : 	}
; 88   : 	if (1==WhichPlane)	{	// 0 & 2

	cmp	r8d, edx
	jne	SHORT $LN32@box_fpu

; 89   : 		coord[0] = ray.pos[0] + MaxT[1] * ray.fwd_dir[0];

	movaps	xmm2, xmm1
	mulss	xmm2, DWORD PTR [rcx+64]
	addss	xmm2, DWORD PTR [rcx+32]

; 90   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm2
	movss	DWORD PTR [r9], xmm2
	ja	SHORT $LN37@box_fpu
	comiss	xmm2, xmm3
	ja	SHORT $LN37@box_fpu

; 91   : 		coord[2] = ray.pos[2] + MaxT[1] * ray.fwd_dir[2];

	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm1, DWORD PTR [rcx+40]

; 92   : 		if((coord[2] < min[2]) || (coord[2] > max[2]))	return false;

	comiss	xmm6, xmm1
	movss	DWORD PTR [r9+8], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm4
	jmp	SHORT $LN262@box_fpu
$LN32@box_fpu:

; 93   : 		return true;
; 94   : 	}
; 95   : 	if (2==WhichPlane)	{	// 0 & 1

	cmp	r8d, r10d
	jne	SHORT $LN37@box_fpu

; 96   : 		coord[0] = ray.pos[0] + MaxT[2] * ray.fwd_dir[0];

	movaps	xmm1, xmm0
	mulss	xmm1, DWORD PTR [rcx+64]
	addss	xmm1, DWORD PTR [rcx+32]

; 97   : 		if((coord[0] < min[0]) || (coord[0] > max[0]))	return false;

	comiss	xmm8, xmm1
	movss	DWORD PTR [r9], xmm1
	ja	SHORT $LN37@box_fpu
	comiss	xmm1, xmm3
	ja	SHORT $LN37@box_fpu

; 98   : 		coord[1] = ray.pos[1] + MaxT[2] * ray.fwd_dir[1];

	mulss	xmm0, DWORD PTR [rcx+68]
	addss	xmm0, DWORD PTR [rcx+36]

; 99   : 		if((coord[1] < min[1]) || (coord[1] > max[1]))	return false;

	comiss	xmm7, xmm0
	movss	DWORD PTR [r9+4], xmm0
	ja	SHORT $LN37@box_fpu
	comiss	xmm0, xmm5
$LN262@box_fpu:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 213  :         return 		isect_fpu	(BB.min,BB.max,ray,coord);

	jbe	SHORT $LN7@box_fpu
$LN37@box_fpu:
	xor	edx, edx
$LN7@box_fpu:

; 214  : 	}

	movaps	xmm6, XMMWORD PTR [rsp+64]
	mov	eax, edx
	movaps	xmm7, XMMWORD PTR [rsp+48]
	movaps	xmm8, XMMWORD PTR [rsp+32]
	movaps	xmm9, XMMWORD PTR [rsp+16]
	add	rsp, 88					; 00000058H
	ret	0
?_box_fpu@?$ray_collider@$00$00$00$00@@QEAAHAEBU?$_vector3@M@@0AEAU2@@Z ENDP ; ray_collider<1,1,1,1>::_box_fpu
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
tv771 = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,0,0,0>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm9
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+r11*4+4]
	movss	xmm3, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	subss	xmm10, xmm3
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	subss	xmm11, xmm5
	subss	xmm12, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm5
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm3

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm1, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm9, xmm13
	mulss	xmm9, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm9, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm2, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm10

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm1, xmm0
	movaps	xmm0, xmm9
	mulss	xmm0, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv771[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm12
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN9@tri
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN11@tri
$LN9@tri:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm4, xmm3
	movss	xmm3, DWORD PTR [rcx+36]
	subss	xmm3, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rcx+40]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm2, DWORD PTR [rbx+r11*4+8]
	movaps	xmm5, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm5, xmm9
	xorps	xmm9, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR tv771[rsp]
	addss	xmm5, xmm0
	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm5
	movss	DWORD PTR [r8], xmm5
	ja	$LN11@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN11@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm3
	movaps	xmm0, xmm2

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm10
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm2, xmm0
	subss	xmm4, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm3, xmm6
	mulss	xmm3, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm3
	movss	DWORD PTR [r9], xmm3
	ja	SHORT $LN11@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN11@tri

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm4, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN11@tri:

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm7, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,0,0,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
tv771 = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,0,0,1>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm9
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+r11*4+4]
	movss	xmm3, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	subss	xmm10, xmm3
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	subss	xmm11, xmm5
	subss	xmm12, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm5
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm3

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm1, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm9, xmm13
	mulss	xmm9, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm9, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm2, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm10

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm1, xmm0
	movaps	xmm0, xmm9
	mulss	xmm0, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv771[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm12
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN9@tri
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN11@tri
$LN9@tri:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm4, xmm3
	movss	xmm3, DWORD PTR [rcx+36]
	subss	xmm3, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rcx+40]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm2, DWORD PTR [rbx+r11*4+8]
	movaps	xmm5, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm5, xmm9
	xorps	xmm9, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR tv771[rsp]
	addss	xmm5, xmm0
	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm5
	movss	DWORD PTR [r8], xmm5
	ja	$LN11@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN11@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm3
	movaps	xmm0, xmm2

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm10
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm2, xmm0
	subss	xmm4, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm3, xmm6
	mulss	xmm3, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm3
	movss	DWORD PTR [r9], xmm3
	ja	SHORT $LN11@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN11@tri

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm4, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN11@tri:

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm7, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,0,0,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
tv771 = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,0,1,0>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm9
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+r11*4+4]
	movss	xmm3, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	subss	xmm10, xmm3
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	subss	xmm11, xmm5
	subss	xmm12, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm5
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm3

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm1, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm9, xmm13
	mulss	xmm9, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm9, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm2, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm10

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm1, xmm0
	movaps	xmm0, xmm9
	mulss	xmm0, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv771[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm12
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN9@tri
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN11@tri
$LN9@tri:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm4, xmm3
	movss	xmm3, DWORD PTR [rcx+36]
	subss	xmm3, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rcx+40]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm2, DWORD PTR [rbx+r11*4+8]
	movaps	xmm5, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm5, xmm9
	xorps	xmm9, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR tv771[rsp]
	addss	xmm5, xmm0
	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm5
	movss	DWORD PTR [r8], xmm5
	ja	$LN11@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN11@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm3
	movaps	xmm0, xmm2

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm10
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm2, xmm0
	subss	xmm4, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm3, xmm6
	mulss	xmm3, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm3
	movss	DWORD PTR [r9], xmm3
	ja	SHORT $LN11@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN11@tri

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm4, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN11@tri:

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm7, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,0,1,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
tv771 = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,0,1,1>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm9
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+r11*4+4]
	movss	xmm3, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	subss	xmm10, xmm3
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	subss	xmm11, xmm5
	subss	xmm12, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm5
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm3

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm1, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm9, xmm13
	mulss	xmm9, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm9, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm2, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm10

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm1, xmm0
	movaps	xmm0, xmm9
	mulss	xmm0, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv771[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm12
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN9@tri
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN11@tri
$LN9@tri:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm4, xmm3
	movss	xmm3, DWORD PTR [rcx+36]
	subss	xmm3, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rcx+40]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm2, DWORD PTR [rbx+r11*4+8]
	movaps	xmm5, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm5, xmm9
	xorps	xmm9, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR tv771[rsp]
	addss	xmm5, xmm0
	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm5
	movss	DWORD PTR [r8], xmm5
	ja	$LN11@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN11@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm3
	movaps	xmm0, xmm2

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm10
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm2, xmm0
	subss	xmm4, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm3, xmm6
	mulss	xmm3, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm3
	movss	DWORD PTR [r9], xmm3
	ja	SHORT $LN11@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN11@tri

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm4, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN11@tri:

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm7, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$0A@$00$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,0,1,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,1,0,0>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+32], xmm13
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	subss	xmm9, xmm2
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	subss	xmm10, xmm3
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm3
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm12, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm12, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm8, xmm13
	mulss	xmm8, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm8, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm12, xmm0
	movaps	xmm7, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm7, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm9
	movaps	xmm1, xmm12
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm4, xmm3
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm3, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm3, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, xmm12
	xorps	xmm8, xmm8
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm8, xmm3
	movss	DWORD PTR [r8], xmm3
	ja	$LN6@tri
	comiss	xmm3, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm4
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm9
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm2, xmm0
	subss	xmm5, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm4, xmm6
	mulss	xmm4, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm8, xmm4
	movss	DWORD PTR [r9], xmm4
	ja	SHORT $LN6@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN6@tri

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000

; 260  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	divss	xmm0, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [r8], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 262  : 			v		*= inv_det;

	movss	DWORD PTR [r9], xmm4
	mulss	xmm2, xmm0
	movss	DWORD PTR [rax], xmm2

; 263  : 		}
; 264  : 		else
; 265  : 		{			
; 266  : 			if (det > -EPS && det < EPS) return false;
; 267  : 			inv_det = 1.0f / det;
; 268  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 270  : 			if (u < 0.0f || u > 1.0f)    return false;
; 271  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN6@tri:

; 254  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,1,0,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,1,0,1>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+32], xmm13
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	subss	xmm9, xmm2
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	subss	xmm10, xmm3
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm3
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm12, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm12, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm8, xmm13
	mulss	xmm8, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm8, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm12, xmm0
	movaps	xmm7, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm7, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm9
	movaps	xmm1, xmm12
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm4, xmm3
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm3, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm3, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, xmm12
	xorps	xmm8, xmm8
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm8, xmm3
	movss	DWORD PTR [r8], xmm3
	ja	$LN6@tri
	comiss	xmm3, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm4
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm9
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm2, xmm0
	subss	xmm5, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm4, xmm6
	mulss	xmm4, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm8, xmm4
	movss	DWORD PTR [r9], xmm4
	ja	SHORT $LN6@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN6@tri

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000

; 260  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	divss	xmm0, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [r8], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 262  : 			v		*= inv_det;

	movss	DWORD PTR [r9], xmm4
	mulss	xmm2, xmm0
	movss	DWORD PTR [rax], xmm2

; 263  : 		}
; 264  : 		else
; 265  : 		{			
; 266  : 			if (det > -EPS && det < EPS) return false;
; 267  : 			inv_det = 1.0f / det;
; 268  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 270  : 			if (u < 0.0f || u > 1.0f)    return false;
; 271  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN6@tri:

; 254  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$00$0A@$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,1,0,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,1,1,0>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+32], xmm13
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	subss	xmm9, xmm2
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	subss	xmm10, xmm3
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm3
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm12, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm12, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm8, xmm13
	mulss	xmm8, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm8, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm12, xmm0
	movaps	xmm7, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm7, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm9
	movaps	xmm1, xmm12
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm4, xmm3
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm3, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm3, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, xmm12
	xorps	xmm8, xmm8
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm8, xmm3
	movss	DWORD PTR [r8], xmm3
	ja	$LN6@tri
	comiss	xmm3, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm4
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm9
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm2, xmm0
	subss	xmm5, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm4, xmm6
	mulss	xmm4, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm8, xmm4
	movss	DWORD PTR [r9], xmm4
	ja	SHORT $LN6@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN6@tri

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000

; 260  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	divss	xmm0, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [r8], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 262  : 			v		*= inv_det;

	movss	DWORD PTR [r9], xmm4
	mulss	xmm2, xmm0
	movss	DWORD PTR [rax], xmm2

; 263  : 		}
; 264  : 		else
; 265  : 		{			
; 266  : 			if (det > -EPS && det < EPS) return false;
; 267  : 			inv_det = 1.0f / det;
; 268  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 270  : 			if (u < 0.0f || u > 1.0f)    return false;
; 271  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN6@tri:

; 254  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$00$00$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,1,1,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<0,1,1,1>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+32], xmm13
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	subss	xmm9, xmm2
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	subss	xmm10, xmm3
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm3
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm12, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm12, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm8, xmm13
	mulss	xmm8, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm8, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm12, xmm0
	movaps	xmm7, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm7, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm9
	movaps	xmm1, xmm12
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm4, xmm3
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm3, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm3, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, xmm12
	xorps	xmm8, xmm8
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm8, xmm3
	movss	DWORD PTR [r8], xmm3
	ja	$LN6@tri
	comiss	xmm3, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm4
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm9
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm2, xmm0
	subss	xmm5, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm4, xmm6
	mulss	xmm4, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm8, xmm4
	movss	DWORD PTR [r9], xmm4
	ja	SHORT $LN6@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN6@tri

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000

; 260  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	divss	xmm0, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [r8], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 262  : 			v		*= inv_det;

	movss	DWORD PTR [r9], xmm4
	mulss	xmm2, xmm0
	movss	DWORD PTR [rax], xmm2

; 263  : 		}
; 264  : 		else
; 265  : 		{			
; 266  : 			if (det > -EPS && det < EPS) return false;
; 267  : 			inv_det = 1.0f / det;
; 268  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 270  : 			if (u < 0.0f || u > 1.0f)    return false;
; 271  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN6@tri:

; 254  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$0A@$00$00$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<0,1,1,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
tv771 = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,0,0,0>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm9
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+r11*4+4]
	movss	xmm3, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	subss	xmm10, xmm3
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	subss	xmm11, xmm5
	subss	xmm12, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm5
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm3

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm1, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm9, xmm13
	mulss	xmm9, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm9, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm2, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm10

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm1, xmm0
	movaps	xmm0, xmm9
	mulss	xmm0, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv771[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm12
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN9@tri
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN11@tri
$LN9@tri:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm4, xmm3
	movss	xmm3, DWORD PTR [rcx+36]
	subss	xmm3, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rcx+40]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm2, DWORD PTR [rbx+r11*4+8]
	movaps	xmm5, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm5, xmm9
	xorps	xmm9, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR tv771[rsp]
	addss	xmm5, xmm0
	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm5
	movss	DWORD PTR [r8], xmm5
	ja	$LN11@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN11@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm3
	movaps	xmm0, xmm2

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm10
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm2, xmm0
	subss	xmm4, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm3, xmm6
	mulss	xmm3, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm3
	movss	DWORD PTR [r9], xmm3
	ja	SHORT $LN11@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN11@tri

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm4, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN11@tri:

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm7, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$0A@$0A@$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,0,0,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
tv771 = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,0,0,1>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm9
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+r11*4+4]
	movss	xmm3, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	subss	xmm10, xmm3
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	subss	xmm11, xmm5
	subss	xmm12, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm5
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm3

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm1, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm9, xmm13
	mulss	xmm9, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm9, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm2, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm10

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm1, xmm0
	movaps	xmm0, xmm9
	mulss	xmm0, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv771[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm12
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN9@tri
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN11@tri
$LN9@tri:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm4, xmm3
	movss	xmm3, DWORD PTR [rcx+36]
	subss	xmm3, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rcx+40]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm2, DWORD PTR [rbx+r11*4+8]
	movaps	xmm5, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm5, xmm9
	xorps	xmm9, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR tv771[rsp]
	addss	xmm5, xmm0
	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm5
	movss	DWORD PTR [r8], xmm5
	ja	$LN11@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN11@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm3
	movaps	xmm0, xmm2

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm10
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm2, xmm0
	subss	xmm4, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm3, xmm6
	mulss	xmm3, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm3
	movss	DWORD PTR [r9], xmm3
	ja	SHORT $LN11@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN11@tri

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm4, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN11@tri:

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm7, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$0A@$0A@$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,0,0,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
tv771 = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,0,1,0>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm9
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+r11*4+4]
	movss	xmm3, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	subss	xmm10, xmm3
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	subss	xmm11, xmm5
	subss	xmm12, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm5
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm3

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm1, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm9, xmm13
	mulss	xmm9, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm9, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm2, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm10

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm1, xmm0
	movaps	xmm0, xmm9
	mulss	xmm0, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv771[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm12
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN9@tri
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN11@tri
$LN9@tri:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm4, xmm3
	movss	xmm3, DWORD PTR [rcx+36]
	subss	xmm3, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rcx+40]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm2, DWORD PTR [rbx+r11*4+8]
	movaps	xmm5, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm5, xmm9
	xorps	xmm9, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR tv771[rsp]
	addss	xmm5, xmm0
	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm5
	movss	DWORD PTR [r8], xmm5
	ja	$LN11@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN11@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm3
	movaps	xmm0, xmm2

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm10
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm2, xmm0
	subss	xmm4, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm3, xmm6
	mulss	xmm3, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm3
	movss	DWORD PTR [r9], xmm3
	ja	SHORT $LN11@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN11@tri

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm4, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN11@tri:

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm7, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$0A@$00$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,0,1,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
tv771 = 160
this$ = 160
p$ = 168
u$ = 176
v$ = 184
range$ = 192
?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,0,1,1>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 144				; 00000090H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm9
	movaps	XMMWORD PTR [rax-72], xmm10
	movaps	XMMWORD PTR [rax-88], xmm11
	movaps	XMMWORD PTR [rax-104], xmm12
	movaps	XMMWORD PTR [rax-120], xmm13
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rbx+r11*4+4]
	movss	xmm3, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm10, DWORD PTR [rbx+r10*4]
	movss	xmm11, DWORD PTR [rbx+r10*4+4]
	subss	xmm10, xmm3
	movss	xmm12, DWORD PTR [rbx+r10*4+8]
	subss	xmm11, xmm5
	subss	xmm12, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm5
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm3

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm1, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm1, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm9, xmm13
	mulss	xmm9, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm9, xmm0

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm2, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm0, xmm13

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm10

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm1, xmm0
	movaps	xmm0, xmm9
	mulss	xmm0, xmm11

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm0

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movss	DWORD PTR tv771[rsp], xmm1

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm1, xmm12
	addss	xmm2, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 266  : 			if (det > -EPS && det < EPS) return false;

	comiss	xmm2, DWORD PTR __real@b727c5ac
	jbe	SHORT $LN9@tri
	movss	xmm0, DWORD PTR __real@3727c5ac
	comiss	xmm0, xmm2
	ja	$LN11@tri
$LN9@tri:
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm4, DWORD PTR [rcx+32]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	movss	xmm7, DWORD PTR __real@3f800000
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm4, xmm3
	movss	xmm3, DWORD PTR [rcx+36]
	subss	xmm3, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 267  : 			inv_det = 1.0f / det;

	divss	xmm7, xmm2
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm2, DWORD PTR [rcx+40]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm4

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	subss	xmm2, DWORD PTR [rbx+r11*4+8]
	movaps	xmm5, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm5, xmm9
	xorps	xmm9, xmm9

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, DWORD PTR tv771[rsp]
	addss	xmm5, xmm0
	addss	xmm5, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds

	mulss	xmm5, xmm7

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	comiss	xmm9, xmm5
	movss	DWORD PTR [r8], xmm5
	ja	$LN11@tri
	comiss	xmm5, DWORD PTR __real@3f800000
	ja	$LN11@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm3
	movaps	xmm0, xmm2

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm3, xmm10
	mulss	xmm0, xmm11
	mulss	xmm6, xmm12
	mulss	xmm2, xmm10
	subss	xmm6, xmm0
	movaps	xmm0, xmm4
	mulss	xmm0, xmm12
	mulss	xmm4, xmm11
	subss	xmm2, xmm0
	subss	xmm4, xmm3

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm3, xmm6
	mulss	xmm3, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm4
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds

	mulss	xmm3, xmm7

; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;

	comiss	xmm9, xmm3
	movss	DWORD PTR [r9], xmm3
	ja	SHORT $LN11@tri
	addss	xmm3, xmm5
	comiss	xmm3, DWORD PTR __real@3f800000
	ja	SHORT $LN11@tri

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mov	rax, QWORD PTR range$[rsp]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm4, xmm15
	addss	xmm2, xmm6
	addss	xmm2, xmm4
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle

	mulss	xmm2, xmm7
	movss	DWORD PTR [rax], xmm2

; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN11@tri:

; 270  : 			if (u < 0.0f || u > 1.0f)    return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm7, XMMWORD PTR [rsp+112]
	lea	r11, QWORD PTR [rsp+144]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm9, XMMWORD PTR [r11-48]
	movaps	xmm10, XMMWORD PTR [r11-64]
	movaps	xmm11, XMMWORD PTR [r11-80]
	movaps	xmm12, XMMWORD PTR [r11-96]
	movaps	xmm13, XMMWORD PTR [r11-112]
	movaps	xmm14, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$0A@$00$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,0,1,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,1,0,0>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+32], xmm13
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	subss	xmm9, xmm2
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	subss	xmm10, xmm3
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm3
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm12, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm12, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm8, xmm13
	mulss	xmm8, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm8, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm12, xmm0
	movaps	xmm7, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm7, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm9
	movaps	xmm1, xmm12
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm4, xmm3
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm3, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm3, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, xmm12
	xorps	xmm8, xmm8
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm8, xmm3
	movss	DWORD PTR [r8], xmm3
	ja	$LN6@tri
	comiss	xmm3, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm4
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm9
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm2, xmm0
	subss	xmm5, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm4, xmm6
	mulss	xmm4, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm8, xmm4
	movss	DWORD PTR [r9], xmm4
	ja	SHORT $LN6@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN6@tri

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000

; 260  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	divss	xmm0, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [r8], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 262  : 			v		*= inv_det;

	movss	DWORD PTR [r9], xmm4
	mulss	xmm2, xmm0
	movss	DWORD PTR [rax], xmm2

; 263  : 		}
; 264  : 		else
; 265  : 		{			
; 266  : 			if (det > -EPS && det < EPS) return false;
; 267  : 			inv_det = 1.0f / det;
; 268  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 270  : 			if (u < 0.0f || u > 1.0f)    return false;
; 271  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN6@tri:

; 254  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$00$0A@$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,1,0,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,1,0,1>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+32], xmm13
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	subss	xmm9, xmm2
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	subss	xmm10, xmm3
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm3
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm12, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm12, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm8, xmm13
	mulss	xmm8, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm8, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm12, xmm0
	movaps	xmm7, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm7, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm9
	movaps	xmm1, xmm12
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm4, xmm3
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm3, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm3, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, xmm12
	xorps	xmm8, xmm8
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm8, xmm3
	movss	DWORD PTR [r8], xmm3
	ja	$LN6@tri
	comiss	xmm3, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm4
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm9
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm2, xmm0
	subss	xmm5, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm4, xmm6
	mulss	xmm4, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm8, xmm4
	movss	DWORD PTR [r9], xmm4
	ja	SHORT $LN6@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN6@tri

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000

; 260  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	divss	xmm0, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [r8], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 262  : 			v		*= inv_det;

	movss	DWORD PTR [r9], xmm4
	mulss	xmm2, xmm0
	movss	DWORD PTR [rax], xmm2

; 263  : 		}
; 264  : 		else
; 265  : 		{			
; 266  : 			if (det > -EPS && det < EPS) return false;
; 267  : 			inv_det = 1.0f / det;
; 268  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 270  : 			if (u < 0.0f || u > 1.0f)    return false;
; 271  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN6@tri:

; 254  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$00$0A@$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,1,0,1>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,1,1,0>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+32], xmm13
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	subss	xmm9, xmm2
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	subss	xmm10, xmm3
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm3
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm12, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm12, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm8, xmm13
	mulss	xmm8, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm8, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm12, xmm0
	movaps	xmm7, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm7, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm9
	movaps	xmm1, xmm12
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm4, xmm3
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm3, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm3, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, xmm12
	xorps	xmm8, xmm8
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm8, xmm3
	movss	DWORD PTR [r8], xmm3
	ja	$LN6@tri
	comiss	xmm3, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm4
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm9
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm2, xmm0
	subss	xmm5, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm4, xmm6
	mulss	xmm4, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm8, xmm4
	movss	DWORD PTR [r9], xmm4
	ja	SHORT $LN6@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN6@tri

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000

; 260  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	divss	xmm0, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [r8], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 262  : 			v		*= inv_det;

	movss	DWORD PTR [r9], xmm4
	mulss	xmm2, xmm0
	movss	DWORD PTR [rax], xmm2

; 263  : 		}
; 264  : 		else
; 265  : 		{			
; 266  : 			if (det > -EPS && det < EPS) return false;
; 267  : 			inv_det = 1.0f / det;
; 268  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 270  : 			if (u < 0.0f || u > 1.0f)    return false;
; 271  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN6@tri:

; 254  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$00$00$0A@@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,1,1,0>::_tri
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp
;	COMDAT ?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z
_TEXT	SEGMENT
this$ = 176
p$ = 184
u$ = 192
v$ = 200
range$ = 208
?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z PROC ; ray_collider<1,1,1,1>::_tri, COMDAT

; 235  : 	{

$LN44:
	mov	rax, rsp
	push	rbx
	sub	rsp, 160				; 000000a0H

; 236  : 		Fvector edge1, edge2, tvec, pvec, qvec;
; 237  : 		float	det,inv_det;
; 238  : 		
; 239  : 		// find vectors for two edges sharing vert0
; 240  : 		Fvector&			p0	= verts[ p[0] ];

	mov	rbx, QWORD PTR [rcx+16]
	movaps	XMMWORD PTR [rax-24], xmm6
	movaps	XMMWORD PTR [rax-40], xmm7
	movaps	XMMWORD PTR [rax-56], xmm8
	movaps	XMMWORD PTR [rax-72], xmm9
	movaps	XMMWORD PTR [rax-88], xmm10
	movaps	XMMWORD PTR [rax-104], xmm11
	movaps	XMMWORD PTR [rax-120], xmm12
	mov	eax, DWORD PTR [rdx]
	movaps	XMMWORD PTR [rsp+32], xmm13
	movaps	XMMWORD PTR [rsp+16], xmm14
	movaps	XMMWORD PTR [rsp], xmm15
	lea	r11, QWORD PTR [rax+rax*2]

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	mov	eax, DWORD PTR [rdx+4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm3, DWORD PTR [rbx+r11*4+4]
	movss	xmm2, DWORD PTR [rbx+r11*4]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 241  : 		Fvector&			p1	= verts[ p[1] ];

	lea	r10, QWORD PTR [rax+rax*2]

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	mov	eax, DWORD PTR [rdx+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm9, DWORD PTR [rbx+r10*4]
	movss	xmm10, DWORD PTR [rbx+r10*4+4]
	subss	xmm9, xmm2
	movss	xmm11, DWORD PTR [rbx+r10*4+8]
	subss	xmm10, xmm3
	subss	xmm11, DWORD PTR [rbx+r11*4+8]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 242  : 		Fvector&			p2	= verts[ p[2] ];

	lea	rdx, QWORD PTR [rax+rax*2]
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm14, DWORD PTR [rbx+rdx*4+4]
	movss	xmm15, DWORD PTR [rbx+rdx*4+8]
	subss	xmm14, xmm3
	movss	xmm13, DWORD PTR [rbx+rdx*4]
	subss	xmm15, DWORD PTR [rbx+r11*4+8]
	subss	xmm13, xmm2

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm0, xmm14

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	movaps	xmm12, xmm14
	mulss	xmm0, DWORD PTR [rcx+72]
	mulss	xmm12, DWORD PTR [rcx+64]
	movaps	xmm6, xmm15
	mulss	xmm6, DWORD PTR [rcx+68]
	movaps	xmm8, xmm13
	mulss	xmm8, DWORD PTR [rcx+72]
	subss	xmm6, xmm0
	movaps	xmm0, xmm15
	mulss	xmm0, DWORD PTR [rcx+64]
	subss	xmm8, xmm0
	movaps	xmm0, xmm13
	mulss	xmm0, DWORD PTR [rcx+68]
	subss	xmm12, xmm0
	movaps	xmm7, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm6

; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm7, xmm10

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm9
	movaps	xmm1, xmm12
	mulss	xmm1, xmm11
	addss	xmm7, xmm0
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	movss	xmm0, DWORD PTR __real@3727c5ac
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm7, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 251  : 			if (det < EPS)  return false;

	comiss	xmm0, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movss	xmm5, DWORD PTR [rcx+32]
	movss	xmm4, DWORD PTR [rcx+36]
	subss	xmm5, xmm2
	movss	xmm2, DWORD PTR [rcx+40]
	subss	xmm4, xmm3
	subss	xmm2, DWORD PTR [rbx+r11*4+8]

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm0, xmm5

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	movaps	xmm3, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm0, xmm6

; 37   :     ICF SelfRef sub(const Self& a, const Self& v) { x = a.x - v.x; y = a.y - v.y; z = a.z - v.z; return *this; };

	mulss	xmm3, xmm8

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm1, xmm2
	mulss	xmm1, xmm12
	xorps	xmm8, xmm8
	addss	xmm3, xmm0
	addss	xmm3, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 254  : 			if (u < 0.f || u > det) return false;

	comiss	xmm8, xmm3
	movss	DWORD PTR [r8], xmm3
	ja	$LN6@tri
	comiss	xmm3, xmm7
	ja	$LN6@tri
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 282  :         x = v1.y * v2.z - v1.z * v2.y;

	movaps	xmm6, xmm4
	movaps	xmm0, xmm2
	mulss	xmm0, xmm10

; 283  :         y = v1.z * v2.x - v1.x * v2.z;
; 284  :         z = v1.x * v2.y - v1.y * v2.x;

	mulss	xmm4, xmm9
	mulss	xmm6, xmm11
	mulss	xmm2, xmm9
	subss	xmm6, xmm0
	movaps	xmm0, xmm5
	mulss	xmm0, xmm11
	mulss	xmm5, xmm10
	subss	xmm2, xmm0
	subss	xmm5, xmm4

; 276  :         return x*v.x + y*v.y + z*v.z;

	movaps	xmm4, xmm6
	mulss	xmm4, DWORD PTR [rcx+64]
	movaps	xmm0, xmm2
	mulss	xmm0, DWORD PTR [rcx+68]
	movaps	xmm1, xmm5
	mulss	xmm1, DWORD PTR [rcx+72]
	addss	xmm4, xmm0
	addss	xmm4, xmm1
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 257  : 			if (v < 0.f || u + v > det) return false;

	comiss	xmm8, xmm4
	movss	DWORD PTR [r9], xmm4
	ja	SHORT $LN6@tri
	movaps	xmm0, xmm4
	addss	xmm0, xmm3
	comiss	xmm0, xmm7
	ja	SHORT $LN6@tri

; 258  : 			range = edge2.dotproduct(qvec);				// calculate t, scale parameters, ray intersects triangle
; 259  : 			inv_det = 1.0f / det;

	movss	xmm0, DWORD PTR __real@3f800000

; 260  : 			range	*= inv_det;

	mov	rax, QWORD PTR range$[rsp]
	divss	xmm0, xmm7
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	mulss	xmm2, xmm14
	mulss	xmm6, xmm13
	mulss	xmm5, xmm15
	addss	xmm2, xmm6
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 261  : 			u		*= inv_det;

	mulss	xmm3, xmm0

; 262  : 			v		*= inv_det;

	mulss	xmm4, xmm0
	movss	DWORD PTR [r8], xmm3
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCore\_vector3d.h

; 276  :         return x*v.x + y*v.y + z*v.z;

	addss	xmm2, xmm5
; File C:\GitHub\Engine_Call_of_Chernobyl_x64\src\xrCDB\xrCDB_ray.cpp

; 262  : 			v		*= inv_det;

	movss	DWORD PTR [r9], xmm4
	mulss	xmm2, xmm0
	movss	DWORD PTR [rax], xmm2

; 263  : 		}
; 264  : 		else
; 265  : 		{			
; 266  : 			if (det > -EPS && det < EPS) return false;
; 267  : 			inv_det = 1.0f / det;
; 268  : 			tvec.sub(ray.pos, p0);						// calculate distance from vert0 to ray origin
; 269  : 			u = tvec.dotproduct(pvec)*inv_det;			// calculate U parameter and test bounds
; 270  : 			if (u < 0.0f || u > 1.0f)    return false;
; 271  : 			qvec.crossproduct(tvec, edge1);				// prepare to test V parameter
; 272  : 			v = ray.fwd_dir.dotproduct(qvec)*inv_det;	// calculate V parameter and test bounds
; 273  : 			if (v < 0.0f || u + v > 1.0f) return false;
; 274  : 			range = edge2.dotproduct(qvec)*inv_det;		// calculate t, ray intersects triangle
; 275  : 		}
; 276  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@tri
$LN6@tri:

; 254  : 			if (u < 0.f || u > det) return false;

	xor	al, al
$LN1@tri:

; 277  : 	}

	movaps	xmm14, XMMWORD PTR [rsp+16]
	lea	r11, QWORD PTR [rsp+160]
	movaps	xmm6, XMMWORD PTR [r11-16]
	movaps	xmm7, XMMWORD PTR [r11-32]
	movaps	xmm8, XMMWORD PTR [r11-48]
	movaps	xmm9, XMMWORD PTR [r11-64]
	movaps	xmm10, XMMWORD PTR [r11-80]
	movaps	xmm11, XMMWORD PTR [r11-96]
	movaps	xmm12, XMMWORD PTR [r11-112]
	movaps	xmm13, XMMWORD PTR [r11-128]
	movaps	xmm15, XMMWORD PTR [rsp]
	mov	rsp, r11
	pop	rbx
	ret	0
?_tri@?$ray_collider@$00$00$00$00@@QEAA_NPEAIAEAM11@Z ENDP ; ray_collider<1,1,1,1>::_tri
_TEXT	ENDS
END
